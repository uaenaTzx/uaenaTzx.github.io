<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://uaenaTzx.github.io</id>
    <title>Uaena_blog</title>
    <updated>2022-05-16T09:05:23.121Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://uaenaTzx.github.io"/>
    <link rel="self" href="https://uaenaTzx.github.io/atom.xml"/>
    <subtitle>èœç‹—tzxçš„ç¬”è®°åšå®¢ğŸ•</subtitle>
    <logo>https://uaenaTzx.github.io/images/avatar.png</logo>
    <icon>https://uaenaTzx.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Uaena_blog</rights>
    <entry>
        <title type="html"><![CDATA[asyncã€awaitå‡½æ•°çš„åŸç†è§£æ]]></title>
        <id>https://uaenaTzx.github.io/post/asyncawait-han-shu-de-yuan-li-jie-xi/</id>
        <link href="https://uaenaTzx.github.io/post/asyncawait-han-shu-de-yuan-li-jie-xi/">
        </link>
        <updated>2022-05-15T14:28:17.000Z</updated>
        <content type="html"><![CDATA[<h1 id="ä»€ä¹ˆæ˜¯async-awaitå‡½æ•°">ä»€ä¹ˆæ˜¯asyncã€awaitå‡½æ•°</h1>
<p>ç®€è€Œè¨€ä¹‹ï¼Œ<code>async/await</code>æ˜¯é’ˆå¯¹jså¼‚æ­¥é—®é¢˜çš„ä¸€ç§å¼ºæœ‰åŠ›çš„å¤„ç†æ–¹æ³•ã€‚</p>
<p>å¦‚æœå°†<code>async</code>æ”¾åœ¨å‡½æ•°å£°æ˜ä¹‹å‰ï¼Œåˆ™è¡¨æ˜è¯¥å‡½æ•°æ˜¯ä¸€ä¸ªä¼šè¿”å›<code>Promise</code>å¯¹è±¡çš„å¼‚æ­¥å‡½æ•°ã€‚<br>
<code>await</code>å¿…é¡»å’Œ<code>async</code>ä¸€èµ·ä½¿ç”¨<font color="red">ï¼ˆæœ‰<code>await</code>å¿…æœ‰<code>async</code>ï¼Œæœ‰<code>async</code>ä¸ä¸€å®šæœ‰<code>await</code>ï¼ï¼ï¼ğŸŒï¼‰</font>ã€‚<br>
å¦‚æœæˆ‘ä»¬å°†<code>await</code>æ”¾åœ¨å¼‚æ­¥å‡½æ•°è°ƒç”¨ä¹‹å‰ï¼Œåˆ™å½“ä»£ç æ‰§è¡Œåˆ°æ­¤å¤„çš„æ—¶å€™ï¼Œä»£ç å°†ä¼šæš‚åœï¼Œç­‰åˆ°å¼‚æ­¥å‡½æ•°æ‰§è¡Œå®Œæˆåï¼Œæ‰ä¼šç»§ç»­å‘ä¸‹æ‰§è¡Œâ€”â€”<font color="red">è¿™æ ·å°±å®ç°äº†å¼‚æ­¥å‡½æ•°çš„åŒæ­¥æ‰§è¡Œ~</font></p>
<p>æ¥ä¸‹æ¥æˆ‘ä»¬ç”¨ä»£ç æ¥æ¼”ç¤ºä¸€é<code>async</code>å’Œ<code>await</code>çš„ä½¿ç”¨ï¼ˆçº¢ç»¿ç¯æ¡ˆä¾‹ï¼‰</p>
<pre><code>        function timer(color, delay) {
            //è¿”å›ä¸€ä¸ªPromiseå¯¹è±¡
            return new Promise((reslove, reject) =&gt; {
                console.log(color)
                setTimeout(() =&gt; {
                    reslove()
                }, delay)
            })
        }

        async function light() {
            await timer('green', 1000)
            await timer('yellow', 2000)
            await timer('red', 3000)

            await light()
        }
        light()
</code></pre>
<p>è¿™æ ·å°±å®ç°äº†ä¸€ä¸ªç®€å•çš„çš„çº¢ç»¿ç¯ç³»ç»Ÿï¼Œé€šè¿‡è¿è¡Œï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°æ•´ä¸ªå‡½æ•°æ˜¯ä»¥åŒæ­¥çš„æ–¹å¼å‘ä¸‹æ‰§è¡Œçš„ã€‚<br>
è€Œè¦æ·±ç©¶å…¶ä¸­çš„åŸç†ï¼Œæˆ‘ä»¬å‘ç°<code>Generator</code>å‡½æ•°å¯ä»¥å®ç°è¿™ä¸ªè¿‡ç¨‹</p>
<h1 id="ä»€ä¹ˆæ˜¯generatorå‡½æ•°">ä»€ä¹ˆæ˜¯Generatorå‡½æ•°</h1>
<p><code>Generator</code>å‡½æ•°æ˜¯ç”±ES6è¯­æ³•æä¾›çš„ä¸€ç§å¼‚æ­¥ç¼–ç¨‹è§£å†³æ–¹æ¡ˆã€‚</p>
<p>å¦‚ä½•ç†è§£<code>Generator</code>å‘¢ï¼Ÿ<br>
<code>Generator</code>å‡½æ•°åœ¨è‡ªå·±çš„å‡½æ•°å†…éƒ¨æœ‰å¤šä¸ªâ€œæ–­ç‚¹â€ï¼Œå¿…é¡»æ‰‹åŠ¨çš„è°ƒç”¨next()æ–¹æ³•æ‰èƒ½æ‰§è¡Œä¸‹ä¸€æ­¥ï¼Œè¿™æ ·çš„æ¨¡å¼å…è®¸æˆ‘ä»¬è‡ªå¦‚åœ°å»æš‚åœ/æ‰§è¡Œå‡½æ•°é‡Œé¢çš„ä»£ç (å¯ä»¥ä¸â€œæŒ¤ç‰™è†â€è¿›è¡Œç±»æ¯”)</p>
<p>ä¸‹é¢æˆ‘ä»¬æ¥èŠä¸€ä¸‹<code>Generator</code>å‡½æ•°çš„ç‰¹å¾ï¼š</p>
<p>â‘  functionå…³é”®å­—å’Œå‡½æ•°åä¹‹é—´æœ‰ä¸€ä¸ª*<br>
(function* generatorDemo() {})<br>
â‘¡ å†…éƒ¨ä½¿ç”¨<code>yield</code>è¿›è¡ŒçŠ¶æ€æ§åˆ¶<br>
â‘¢ ä½¿ç”¨<code>next</code>æ‰§è¡Œä¸‹ä¸€æ­¥æ“ä½œç›´åˆ°é‡åˆ°<code>yield</code>å…³é”®å­—æˆ–è€…<code>return</code></p>
<p>æˆ‘ä»¬é€šè¿‡ç®€å•çš„ä»£ç æ¥å±•ç¤ºä¸€ä¸‹</p>
<pre><code>function* generatorLight() {
        let value1 = yield 'green'
        let value2 = yield 'yellow'
        let value3 = yield 'red'
        console.log(value1 + ' ' + value2 +  ' ' + value3)
    }

    let light = generatorLight();
    console.log(light.next()) 
    console.log(light.next())
    console.log(light.next())
    console.log(light.next()) 
</code></pre>
<p>åœ¨ä¸Šæ–¹ä»£ç ä¸­ï¼Œæˆ‘ä»¬è°ƒç”¨<code>generatorLight()</code>å¹¶ä¸æ˜¯æ‰§è¡Œäº†è¯¥å‡½æ•°ï¼Œè€Œæ˜¯è¿”å›äº†ä¸€ä¸ªæŒ‡å‘å†…éƒ¨çŠ¶æ€çš„<font color="red">æŒ‡é’ˆå¯¹è±¡</font>ã€‚é€šè¿‡<code>next()</code>æ–¹æ³•æ¥ä½¿æŒ‡é’ˆæŒ‡å‘ä¸‹ä¸€ä¸ªçŠ¶æ€ã€‚</p>
<p>æ¯ä¸€æ¬¡nextæ–¹æ³•ä¼šè¿”å›ä¸€ä¸ªå¯¹è±¡ï¼š</p>
<pre><code>    {
        value: xxx
        done:  true/false //æŒ‡é’ˆæ˜¯å¦æŒ‡å‘äº†å‡½æ•°æœ«å°¾ å³å‡½æ•°æ˜¯å¦æ‰§è¡Œå®Œæ¯•
    },
</code></pre>
<p>å…¶ä¸­ï¼Œ<code>value</code>ä»£è¡¨<code>yield</code>åé¢è¡¨è¾¾å¼è¿”å›çš„å€¼ï¼Œå¦‚æœé‡åˆ°<code>return</code>ï¼Œåˆ™å°†<code>return</code>åè·Ÿçš„è¡¨è¾¾å¼çš„å€¼ä½œä¸º<code>value</code>çš„å€¼ã€‚(å¦‚æœå‡½æ•°æ²¡æœ‰<code>return</code>, åˆ™<code>value</code>çš„å€¼ä¸º<code>undefined</code>)<br>
<code>done</code>è¡¨ç¤ºæŒ‡é’ˆæ˜¯å¦éå†å®Œæ‰€æœ‰çš„<code>yield</code>å¯¹è±¡ï¼Œé‡åˆ°<code>return</code>æˆ–è€…å‡½æ•°ç»“æŸæ—¶ï¼Œè¿”å›<code>true</code>(å…¶ä½™éƒ½ä¸º<code>false</code>)ã€‚</p>
<p>howeverï¼Œé€šè¿‡æ‰§è¡Œä»£ç ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°<code>console.log(value1 + ' ' + value2 + ' ' + value3);</code>çš„è¾“å‡ºç»“æœæ˜¯â€œundefined undefined undefinedâ€ã€‚è¿™æ˜¯å› ä¸º<code>yield</code>æœ¬èº«çš„è¿”å›å€¼æ˜¯<code>undefined</code>ã€‚ å¦‚æœæˆ‘ä»¬éœ€è¦ä¸Šä¸€æ­¥çš„<code>yield</code>çš„è¿”å›å€¼ï¼Œæˆ‘ä»¬éœ€è¦å°†ä¸Šä¸€æ­¥çš„è¿”å›å€¼ä¼ å…¥<code>next()</code>ä¸­</p>
<pre><code>function* generatorLight() {
        let value1 = yield 'green'
        let value2 = yield 'yellow'
        let value3 = yield 'red'
        console.log(value1 + ' ' + value2 +  ' ' + value3)
    }

    let light = generatorLight()
    let res1 = light.next()
    let res2 = light.next(res1.value)
    let res3 = light.next(res2.value)
    light.next(res3.value)
</code></pre>
<p>è¿™æ ·å°±å¯ä»¥å¾—åˆ°è¿™æ ·çš„ç»“æœï¼šâ€œgreen yellow redâ€</p>
<p>å¯æ˜¯æˆ‘ä»¬å‘ç°ï¼Œ<code>Generator</code>éœ€è¦æˆ‘ä»¬æ‰‹åŠ¨çš„å»ä¸€æ¬¡æ¬¡æ‰§è¡Œï¼Œä½†åˆšåˆšå®ç°çš„çº¢ç»¿ç¯ç³»ç»Ÿå´å¯ä»¥è‡ªåŠ¨æ‰§è¡Œï¼Œä¸ºäº†è®©<code>Generator</code>ä¹Ÿèƒ½å¤Ÿè‡ªåŠ¨æ‰§è¡Œï¼Œæˆ‘ä»¬åº”è¯¥å¼•å…¥<code>Thunk</code>å‡½æ•°çš„æ€æƒ³</p>
<h1 id="ä»€ä¹ˆæ˜¯thunkå‡½æ•°">ä»€ä¹ˆæ˜¯Thunkå‡½æ•°</h1>
<p><code>Thunk</code>å‡½æ•°æ˜¯æŒ‡å°†ä¸€ä¸ªå¤šå‚æ•°å‡½æ•°æ›¿æ¢æˆä¸€ä¸ªåªæ¥å—<font color="red">å›è°ƒå‡½æ•°</font>ä½œä¸ºå‚æ•°çš„å•å‚æ•°å‡½æ•°ã€‚</p>
<p>ä¸‹é¢é€šè¿‡ä¸€ä¸ªä¾‹å­æ¥ä½“ç°<code>Thunk</code>å‡½æ•°çš„æ€æƒ³</p>
<pre><code> // åŸå‡½æ•°
    readFile(fileName, callback)

    // thunkå‡½æ•°
    function thunk(fileName) {
        return function(callback) {
            return readFile(fileName, callback)
        }
    }

    let file = thunk('a.text')
    file(callback)
</code></pre>
<p>è¿™ä¸ªä¾‹å­åªæ˜¯ä»…ä»…è¯´æ˜<code>thunk</code>çš„æ€æƒ³ï¼Œ æ¥ä¸‹æ¥æˆ‘ä»¬è¦ç”¨<code>thunk</code>çš„æ€æƒ³æ¥åŒ…è£…<code>Generator</code>å‡½æ•°ï¼Œä½¿å®ƒå¯ä»¥è‡ªåŠ¨æ‰§è¡Œã€‚</p>
<pre><code>         // Generatorå‡½æ•°
        function* generatorLight() {
        let value1 = yield 'green'
        let value2 = yield 'yellow'
        let value3 = yield 'red'
        console.log(value1 + ' ' + value2 +  ' ' + value3)
    }

        // thunkåŒ…è£…
        function Thunk(fn) {
            const light = fn()

            function next(data) {
                let res = light.next(data)
                if (res.done) {
                    return res.value
                }
                next(res.value)
            }
            next(undefined)
        }

        Thunk(generatorLight)
</code></pre>
<p>æˆ‘ä»¬åœ¨<code>Thunk</code>å†…éƒ¨å®šä¹‰äº†ä¸€ä¸ª<code>next</code>å‡½æ•°ã€‚é€šè¿‡é€’å½’æ¥è¿›è¡Œè‡ªåŠ¨æ‰§è¡Œ</p>
<h1 id="å®ç°asyncawait">å®ç°async/await</h1>
<p>æ¥ä¸‹æ¥æˆ‘ä»¬ä½¿ç”¨<code>Generator</code>å‡½æ•°æ¥å®ç°<code>async/await</code></p>
<p>é¦–å…ˆï¼Œæˆ‘ä»¬å†æ¥å›é¡¾ä¸€ä¸‹ä¹‹å‰çš„ä»£ç </p>
<pre><code>        function timer(color, delay) {
            //è¿”å›ä¸€ä¸ªPromiseå¯¹è±¡
            return new Promise((reslove, reject) =&gt; {
                console.log(color)
                setTimeout(() =&gt; {
                    reslove()
                }, delay)
            })
        }

        async function light() {
            await timer('green', 1000)
            await timer('yellow', 2000)
            await timer('red', 3000)

            await light()
        }
        light()
</code></pre>
<p>æˆ‘ä»¬å…ˆå°†<code>light</code>å‡½æ•°æ”¹é€ æˆ<code>Generator</code>å‡½æ•°</p>
<pre><code>function* light() {
             yield timer('green', 1000)
             yield timer('yellow', 2000)
             yield timer('red', 3000)

             light()
        }
</code></pre>
<p>æ¥ç€ï¼Œæˆ‘ä»¬å†æ¥å®ç°<code>Thunk</code>å‡½æ•°</p>
<pre><code>   function Thunk(fn) {
       return new Promise((resolve, reject) =&gt; {
           const light = fn()
           function next(data) {
               let res = light.next(data)
               if (res.done) {
                   return resolve(res.value)
               }
               Promise.resolve(res.value).then(res =&gt; {
                   next(res)
               })
           }
           next(undefined)
       })
   }
</code></pre>
<p>åˆ°è¿™é‡Œï¼Œæˆ‘ä»¬å°±å¯ä»¥å®ç°<code>asyncã€await</code>çš„åŠŸèƒ½äº†ï¼Œè¦æ³¨æ„çš„æ˜¯ï¼Œ<font color="red"><code>light</code>çš„é€’å½’éœ€è¦ä½¿ç”¨Thunk(light)!</font><br>
å®Œæ•´ä»£ç å¦‚ä¸‹</p>
<pre><code>function timer(color, delay) {
            //è¿”å›ä¸€ä¸ªPromiseå¯¹è±¡
            return new Promise((reslove, reject) =&gt; {
                console.log(color)
                setTimeout(() =&gt; {
                    reslove()
                }, delay)
            })
        }

       function* light() {
             yield timer('green', 1000)
             yield timer('yellow', 2000)
             yield timer('red', 3000)
             //lighté€’å½’
             Thunk(light)
        }

    function Thunk(fn) {
       return new Promise((resolve, reject) =&gt; {
           const light = fn()
           function next(data) {
               let res = light.next(data)
               if (res.done) {
                   return resolve(res.value)
               }
               Promise.resolve(res.value).then(res =&gt; {
                   next(res)
               })
           }
           next(undefined)
       })
   }

   Thunk(light)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Promiseæ‰‹å†™]]></title>
        <id>https://uaenaTzx.github.io/post/Promise-handwriting/</id>
        <link href="https://uaenaTzx.github.io/post/Promise-handwriting/">
        </link>
        <updated>2022-05-10T04:12:08.000Z</updated>
        <content type="html"><![CDATA[<p>æœ¬ç¯‡å¼€å§‹æ‰‹å†™Promiseï¼Œä»Promiseç±»çš„åŸºæœ¬æ„ä»¶å¼€å§‹</p>
<p>#ä¸€ã€åŸºæœ¬æ„ä»¶</p>
<p><strong>éœ€æ±‚ï¼š</strong><br>
â‘ å®šä¹‰Promiseå¯¹è±¡ï¼Œåœ¨æ„é€ å‡½æ•°ä¸­å®šä¹‰resolveå’Œrejectæ–¹æ³•(ç”¨executor(resolveï¼Œreject)æ ¼å¼)<br>
â‘¡åœ¨æ„é€ å‡½æ•°ä¸­å®šä¹‰stateå‚æ•°ï¼Œåˆå§‹å€¼ä¸ºâ€˜pendingâ€™ï¼ŒåŒæ—¶è®¾æœ‰â€˜fulfiledâ€™ï¼Œâ€˜rejectedâ€™å…±ä¸‰ç§çŠ¶æ€<br>
â‘¢åœ¨æ„é€ å‡½æ•°ä¸­å®šä¹‰valueï¼Œreasonå‚æ•°ï¼Œåˆ†åˆ«å¯¹åº”ä¼ å…¥resolveå’Œrejectçš„å€¼</p>
<p><strong>æ³¨æ„ï¼š</strong><br>
â‘ Promiseçš„stateåªèƒ½æ”¹å˜ä¸€æ¬¡<br>
â‘¡åº”è¯¥ä½¿ç”¨try catchè¯­æ³•å®Œå–„executor(resolveï¼Œreject)çš„æ‰§è¡Œ</p>
<p>ç»¼ä¸Šï¼Œå†™å‡ºçš„ä»£ç å¦‚ä¸‹ï¼š</p>
<pre><code>class Promise {
            constructor(executor) {
                this.state = 'pending'

                this.value = null;//è®°å½•æˆåŠŸçš„å€¼ï¼Œç»™å°†æ¥çš„.then()ä½¿ç”¨
                this.reason = null;//è®°å½•å¤±è´¥çš„å€¼ï¼Œç»™å°†æ¥çš„.catch()ä½¿ç”¨

                const resolve = (value) =&gt; {
                    if (this.state === 'pending') {
                        this.state = 'fulfiled';
                        this.value = value;
                        
                    }
                };

                const reject = (reason) =&gt; {
                    if (this.state === 'pending') {
                        this.state = 'rejected';
                        this.reason = reason;
                        
                    }
                };

                try {
                    executor(resolve, reject);
                } catch (reason) {
                    reject(reason);
                }
            }
        }


        const p = new Promise((resolve, reject) =&gt; {
            //resolveå’Œrejectæ˜¯Promiseå†…éƒ¨å®ç°å¥½çš„å‡½æ•°
            //è¿™é‡Œçš„ä»£ç æ˜¯ç«‹åˆ»å¯æ‰§è¡Œçš„
            resolve(200)
        })

        p.then(res =&gt; {
            console.log(res);
        })
</code></pre>
<p>æ¥ä¸‹æ¥æˆ‘ä»¬æ¥å®Œå–„then()æ–¹æ³•</p>
<p>#äºŒã€then()æ–¹æ³•å®Œå–„</p>
<p><strong>éœ€æ±‚ï¼š</strong><br>
â‘ ä¼ å…¥onFulfiledï¼ŒonRejectedæ–¹æ³•<br>
â‘¡ç”¨onFulfiledï¼ŒonRejectedæ¥æ”¶p.then()ä¼ å…¥çš„valueå’Œreason</p>
<p>ç»¼ä¸Šï¼Œå†™å‡ºçš„ä»£ç å¦‚ä¸‹ï¼š</p>
<pre><code>then(onFulfilled, onRejected) {
                //onFulfilledå¦‚æœæˆåŠŸäº†ï¼Œåº”è¯¥è¢«è°ƒç”¨
                if(this.state==='fulfilled'){
                    onFulfilled(this.value) 
                }
                //onRejectedå¦‚æœæˆåŠŸäº†ï¼Œåº”è¯¥è¢«è°ƒç”¨
                if(this.state==='rejected'){
                    onRejected(this.reason)
                }

            }
</code></pre>
<p>æ¥ä¸‹æ¥æˆ‘ä»¬æ¥è§£å†³å¼‚æ­¥é—®é¢˜</p>
<p>#ä¸‰ã€å¼‚æ­¥é—®é¢˜è§£å†³</p>
<p><strong>é—®é¢˜ï¼š</strong><br>
å½“ä»£ç å¦‚ä¸‹æ—¶ï¼š</p>
<pre><code>const p = new Promise((resolve, reject) =&gt; {
            setTimeout(() =&gt; {
                resolve(200)
            }, 1000)
        })

        p.then(res =&gt; {
            console.log(res);
        })
</code></pre>
<p>ä¼šé‡åˆ°then()åœ¨stateçŠ¶æ€æ”¹å˜ä¹‹å‰å°±æ‰§è¡Œï¼Œå¯¼è‡´æ‰§è¡Œthen()æ—¶çš„stateä»ç„¶æ˜¯pendingçŠ¶æ€</p>
<p><strong>éœ€æ±‚ï¼š</strong><br>
â‘ then()çš„æ‰§è¡Œä¸ç›´æ¥è¾“å‡ºç»“æœï¼Œè€Œæ˜¯å°†å¾—åˆ°çš„æ•°æ®å…ˆå…¨éƒ¨å­˜æ”¾åœ¨ä¸¤ä¸ªæ•°ç»„ä¸­ï¼ˆæˆåŠŸå’Œå¤±è´¥ï¼‰ï¼Œåœ¨resolveæˆ–rejectæ‰§è¡Œåå†å°†æ•°ç»„ä¸­çš„å‡½æ•°è¾“å‡º<br>
â‘¡éœ€è¦å¢åŠ ä¸€ä¸ªifåˆ¤æ–­stateå¦‚æœæ˜¯pendingï¼Œå°†æ•°æ®å­˜å‚¨åœ¨æ•°ç»„ä¸­<br>
â‘¢åœ¨resolveå’Œrejectæ–¹æ³•ä¸­éå†ä¸¤æ•°ç»„å¾—åˆ°æ•°æ®</p>
<p><strong>æ³¨æ„ï¼š</strong><font color="red">(è¿™ä¸ªçœŸçš„å¾ˆé‡è¦ï¼ï¼ï¼ğŸ™‰ğŸ™‰ğŸ™‰)</font><br>
â‘ å‡½æ•°åœ¨æ•°ç»„ä¸­çš„å­˜å‚¨éœ€è¦ç”¨åˆ°å‡½æ•°çš„é—­åŒ…(åœ¨å‡½æ•°çš„å†…éƒ¨åº”ç”¨åˆ°å¤–éƒ¨çš„å‚æ•°)â€”â€”åˆ©ç”¨é—­åŒ…å°†valueæˆ–reasonå‚¨å­˜åœ¨å‡½æ•°ä¸­ï¼Œå¹¶æ•´åˆè‡³æ•°ç»„</p>
<pre><code>//é—­åŒ…
this.onResolvedCallbacks.push(() =&gt; {
                        onFulfilled(this.value)
                    })
//éé—­åŒ…
this.onResolvedCallbacks.push(onFulfilledï¼‰
</code></pre>
<p>ç»¼ä¸Šï¼Œå†™å‡ºçš„ä»£ç å¦‚ä¸‹ï¼š</p>
<pre><code>class Promise {
            constructor(executor) {
                this.state = 'pending'

                this.value = null;
                this.reason = null;

                this.onResolvedCallbacks = [];
                this.onRejectedCallbacks = [];

                const resolve = (value) =&gt; {
                    if (this.state === 'pending') {
                        this.state = 'fulfiled';
                        this.value = value;
                        //éå†æ‰§è¡Œè°ƒç”¨æˆåŠŸçš„æ•°ç»„
                        this.onResolvedCallbacks.forEach(fn =&gt; fn()) //fn()å³ä¸ºå†…éƒ¨å­˜å‚¨çš„å‡½æ•°
                    }
                };

                const reject = (reason) =&gt; {
                    if (this.state === 'pending') {
                        this.state = 'rejected';
                        this.reason = reason;
                        //éå†æ‰§è¡Œè°ƒç”¨å¤±è´¥çš„æ•°ç»„
                        this.onRejectedCallbacks.forEach(fn =&gt; fn())
                    }
                };

                try {
                    executor(resolve, reject);
                } catch (reason) {
                    reject(reason);
                }
            }

            then(onFulfilled, onRejected) {
                //onFulfilledå¦‚æœæˆåŠŸäº†ï¼Œåº”è¯¥è¢«è°ƒç”¨
                if (this.state === 'fulfilled') {
                    onFulfilled(this.value)
                }
                //onRejectedå¦‚æœæˆåŠŸäº†ï¼Œåº”è¯¥è¢«è°ƒç”¨
                if (this.state === 'rejected') {
                    onRejected(this.reason)
                }

                if (this.state === 'pending') {
                    //å°†æˆåŠŸçš„æ—¶å€™è¦å¹²çš„äº‹å‚¨å­˜èµ·æ¥
                    this.onResolvedCallbacks.push(() =&gt; {
                        onFulfilled(this.value)
                    })
                    //å°†å¤±è´¥çš„æ—¶å€™è¦å¹²çš„äº‹å‚¨å­˜èµ·æ¥
                    this.onRejectedCallbacks.push(() =&gt; {
                        onRejected(this.reason)
                    })
                }

            }
        }


        const p = new Promise((resolve, reject) =&gt; {
            //resolveå’Œrejectæ˜¯Promiseå†…éƒ¨å®ç°å¥½çš„å‡½æ•°
            //è¿™é‡Œçš„ä»£ç æ˜¯ç«‹åˆ»å¯æ‰§è¡Œçš„
            setTimeout(() =&gt; {
                resolve(200)
            }, 1000)

        })

        p.then(res =&gt; {
            console.log(res,'1');
        })

        p.then(res =&gt; {
            console.log(res,'2');
        })

        p.then(res =&gt; {
            console.log(res,'3');
        })
</code></pre>
<p>å¾—åˆ°ä»¥ä¸‹ç»“æœ(1så)ï¼š</p>
<blockquote>
<p>200 '1'<br>
200 '2'<br>
200 '3'</p>
</blockquote>
<p>æ¥ä¸‹æ¥æˆ‘ä»¬æ¥å¤„ç†é“¾å¼é—®é¢˜</p>
<p>#å››ã€é“¾å¼é—®é¢˜è§£å†³</p>
<p><strong>éœ€æ±‚ï¼š</strong><br>
â‘ ä¸Šä¸€ä¸ª.thenè¦è¿”å›ä¸€ä¸ªpromiseå¯¹è±¡<br>
â‘¡ä¸‹ä¸€ä¸ª.thençš„å‚æ•°ï¼Œè¦æ‹¿åˆ°ä¸Šä¸€ä¸ª.thençš„å›è°ƒè¿”å›å€¼<br>
â‘¢è®¾ç½®å‚æ•°xä¸ºonFulfilledæˆåŠŸçš„.thenå›è°ƒçš„è¿”å›å€¼ï¼Œå¹¶é€šè¿‡resolve(x)æ¥è¿›è¡Œé“¾å¼æ“ä½œ</p>
<p><strong>æ³¨æ„ï¼š</strong><font color="red">(çœŸçš„å¾ˆç»•ï¼Œå¥½å¥½ç†è§£ä¸€ä¸‹ğŸ¤¡)</font><br>
â‘ ä»£ç è¿ç”¨äº†é€’å½’çš„æ€æƒ³ï¼Œä¸Šä¸€çº§thenè¿”å›Promsieå¯¹è±¡æ¥å»¶ç»­ä¸‹ä¸€çº§çš„thenï¼Œå› æ­¤éœ€è¦åœ¨thenå‡½æ•°ä¸­æ„é€ ä¸€ä¸ªæ–°çš„Promiseå¯¹è±¡å¹¶è¿”å›ï¼Œåœ¨æ–°çš„Promiseå¯¹è±¡ä¸­é€šè¿‡å½“å‰é˜¶æ®µçš„å›è°ƒå‡½æ•°å€¼å†³å®šä¸‹ä¸€æ­¥æ“ä½œ<br>
â‘¡xå¯èƒ½æ˜¯ä¼ å…¥çš„æ™®é€šå€¼ï¼Œä¹Ÿå¯èƒ½æ˜¯Promiseå¯¹è±¡ï¼Œå› æ­¤è¦ç”¨ä¸€ä¸ªå‡½æ•°æ¥åˆ¤æ–­xçš„ç±»å‹å¹¶è¿›è¡Œç›¸åº”çš„å¤„ç†</p>
<p>ç»¼ä¸Šï¼Œå†™å‡ºçš„ä»£ç å¦‚ä¸‹ï¼š</p>
<pre><code>class Promise {
            constructor(executor) {
                this.state = 'pending'

                this.value = null;
                this.reason = null;

                this.onResolvedCallbacks = [];
                this.onRejectedCallbacks = [];

                const resolve = (value) =&gt; {
                    if (this.state === 'pending') {
                        this.state = 'fulfilled';
                        this.value = value;
                        //éå†æ‰§è¡Œè°ƒç”¨æˆåŠŸçš„æ•°ç»„
                        this.onResolvedCallbacks.forEach(fn =&gt; fn()) //fn()å³ä¸ºå†…éƒ¨å­˜å‚¨çš„å‡½æ•°
                    }
                };

                const reject = (reason) =&gt; {
                    if (this.state === 'pending') {
                        this.state = 'rejected';
                        this.reason = reason;
                        //éå†æ‰§è¡Œè°ƒç”¨å¤±è´¥çš„æ•°ç»„
                        this.onRejectedCallbacks.forEach(fn =&gt; fn())
                    }
                };

                try {
                    executor(resolve, reject);
                } catch (reason) {
                    reject(reason);
                }
            }

            then(onFulfilled, onRejected) {
                let promise2 = new Promise((resolve, reject) =&gt; {
                    //onFulfilledå¦‚æœæˆåŠŸäº†ï¼Œåº”è¯¥è¢«è°ƒç”¨
                    if (this.state === 'fulfilled') {
                        //x æ˜¯onFulfilledæˆåŠŸçš„.thenå›è°ƒçš„è¿”å›å€¼
                        let x = onFulfilled(this.value)
                        //å¯¹xè¿›è¡Œåˆ†æ:
                        //1.å¦‚æœæ˜¯æ™®é€šå€¼ï¼Œç›´æ¥è°ƒç”¨resolve
                        //2.å¦‚æœæ˜¯promiseå¯¹è±¡ï¼Œçœ‹promiseæ˜¯å¦æˆåŠŸ

                        //å°†è¿”å›å€¼è¿”å›
                        resolvePromise(x, resolve, reject)
                    }
                    //onRejectedå¦‚æœæˆåŠŸäº†ï¼Œåº”è¯¥è¢«è°ƒç”¨
                    if (this.state === 'rejected') {
                        onRejected(this.reason)
                        let x = onRejected(this.reason)
                        reject(x)
                    }

                    if (this.state === 'pending') {
                        //å°†æˆåŠŸçš„æ—¶å€™è¦å¹²çš„äº‹å‚¨å­˜èµ·æ¥
                        this.onResolvedCallbacks.push(() =&gt; {
                            onFulfilled(this.value)
                        })
                        //å°†å¤±è´¥çš„æ—¶å€™è¦å¹²çš„äº‹å‚¨å­˜èµ·æ¥
                        this.onRejectedCallbacks.push(() =&gt; {
                            onRejected(this.reason)
                        })
                    }
                })
                return promise2
            }
        }

        function resolvePromise(x, resolve, reject) {
            //åˆ¤æ–­ x æ˜¯å¦æ˜¯ä¸€ä¸ªPromiseå¯¹è±¡
            if (x instanceof Promise) {
                // x.then((value) =&gt; {
                //     resolve(value)
                // }, err =&gt; {
                //     reject(err)
                // })

                //ç®€å†™
                x.then(resolve,reject)
            } else {
                resolve(x)
            }
        }

        const p = new Promise((resolve, reject) =&gt; {
            //resolveå’Œrejectæ˜¯Promiseå†…éƒ¨å®ç°å¥½çš„å‡½æ•°
            //è¿™é‡Œçš„ä»£ç æ˜¯ç«‹åˆ»å¯æ‰§è¡Œçš„
            resolve(400)

        })

        p.then(res =&gt; {
            console.log(res);
            return new Promise((resolve, reject) =&gt; {
                resolve(200)
            })
        }).then(data =&gt; {
            console.log(data);
        })
</code></pre>
<p>å¾—åˆ°ä»¥ä¸‹ç»“æœï¼š</p>
<blockquote>
<p>400<br>
200</p>
</blockquote>
<p>æ¥ä¸‹æ¥æˆ‘ä»¬æ¥å®Œå–„Promiseå…¶ä»–å‰©ä½™çš„å†…å®¹ï¼š</p>
<p>#äº”ã€å‰©ä½™å†…å®¹å®Œå–„</p>
<p>1ã€å¾ªç¯è°ƒç”¨&amp;&amp;å¼‚å¸¸æ•è·<br>
<strong>é—®é¢˜ï¼š</strong></p>
<pre><code>const p = new Promise((resolve, reject) =&gt; {
            resolve(400)
        })

const p2 = p.then((data)=&gt;{
            console.log(data);
            return p2
        })
</code></pre>
<p>å…¶ä¸­ï¼Œç¬¬ä¸€ä¸ªp2ç­‰ä»·äºpromise2ï¼Œç¬¬äºŒä¸ªp2ç­‰ä»·äºx(promise2,xçš„å®šä¹‰è¯¦è§å‰æ–‡),æ˜¾ç„¶promise2ä¸å¯èƒ½ç­‰äºx<br>
<strong>éœ€æ±‚ï¼š</strong><br>
â‘ é€šè¿‡åˆ¤æ–­è¯­å¥æ¥è§£å†³ä»¥ä¸ŠçŸ›ç›¾(å†™åœ¨resolvePromsieå’ŒrejectPromsieä¸­)<br>
â‘¡ä½¿ç”¨<em>try catch</em>è¯­æ³•æ¥æ•è·é”™è¯¯</p>
<p><strong>æ³¨æ„ï¼š</strong><br>
â‘ ç”±äºresolvePromsieå’ŒrejectPromsieå†™åœ¨promise2çš„å†…éƒ¨ï¼Œå› æ­¤å¯¼å…¥æ–¹æ³•çš„promise2æ˜¯ä¸å‡†ç¡®çš„ï¼Œ<em>æ­¤å¤„éœ€è¦ä½¿ç”¨å¼‚æ­¥æ“ä½œï¼ˆsetTimeoutï¼ˆï¼ˆï¼‰=&gt;{},0ï¼‰ï¼‰æ¥è§£å†³é—®é¢˜</em></p>
<p>ç»¼ä¸Šï¼Œå†™å‡ºçš„ä»£ç å¦‚ä¸‹ï¼š</p>
<pre><code>class Promise {
            constructor(executor) {
                this.state = 'pending'

                this.value = null;
                this.reason = null;

                this.onResolvedCallbacks = [];
                this.onRejectedCallbacks = [];

                const resolve = (value) =&gt; {
                    if (this.state === 'pending') {
                        this.state = 'fulfilled';
                        this.value = value;
                        //éå†æ‰§è¡Œè°ƒç”¨æˆåŠŸçš„æ•°ç»„
                        this.onResolvedCallbacks.forEach(fn =&gt; fn()) //fn()å³ä¸ºå†…éƒ¨å­˜å‚¨çš„å‡½æ•°
                    }
                };

                const reject = (reason) =&gt; {
                    if (this.state === 'pending') {
                        this.state = 'rejected';
                        this.reason = reason;
                        //éå†æ‰§è¡Œè°ƒç”¨å¤±è´¥çš„æ•°ç»„
                        this.onRejectedCallbacks.forEach(fn =&gt; fn())
                    }
                };

                try {
                    executor(resolve, reject);
                } catch (reason) {
                    reject(reason);
                }
            }

            then(onFulfilled, onRejected) {
                let promise2 = new Promise((resolve, reject) =&gt; {
                    //onFulfilledå¦‚æœæˆåŠŸäº†ï¼Œåº”è¯¥è¢«è°ƒç”¨
                    if (this.state === 'fulfilled') {
                        setTimeout(() =&gt; {
                            try {
                                //x æ˜¯onFulfilledæˆåŠŸçš„.thenå›è°ƒçš„è¿”å›å€¼
                                let x = onFulfilled(this.value)
                                //å¯¹xè¿›è¡Œåˆ†æ:
                                //1.å¦‚æœæ˜¯æ™®é€šå€¼ï¼Œç›´æ¥è°ƒç”¨resolve
                                //2.å¦‚æœæ˜¯promiseå¯¹è±¡ï¼Œçœ‹promiseæ˜¯å¦æˆåŠŸ

                                //å°†è¿”å›å€¼è¿”å›
                                resolvePromise(x, resolve, reject, promise2)
                            } catch (error) {
                                reject(error)
                            }

                        }, 0)

                    }
                    //onRejectedå¤±è´¥æˆåŠŸäº†ï¼Œåº”è¯¥è¢«è°ƒç”¨
                    if (this.state === 'rejected') {
                        setTimeout(() =&gt; {
                            try {
                                let x = onRejected(this.reason)
                                resolvePromise(x, resolve, reject, promise2)
                            } catch (error) {
                                reject(error)
                            }

                        }, 0)
                    }

                    if (this.state === 'pending') {
                        //å°†æˆåŠŸçš„æ—¶å€™è¦å¹²çš„äº‹å‚¨å­˜èµ·æ¥
                        this.onResolvedCallbacks.push(() =&gt; {
                            setTimeout(() =&gt; {
                                try {
                                    let x = onFulfilled(this.value)
                                    resolvePromise(x, resolve, reject, promise2)
                                } catch (error) {
                                    reject(error)
                                }

                            }, 0)
                        })
                        //å°†å¤±è´¥çš„æ—¶å€™è¦å¹²çš„äº‹å‚¨å­˜èµ·æ¥
                        this.onRejectedCallbacks.push(() =&gt; {
                            setTimeout(() =&gt; {
                                try {
                                    let x = onRejected(this.reason)
                                    resolvePromise(x, resolve, reject, promise2)
                                } catch (error) {
                                    reject(error)
                                }

                            }, 0)
                        })
                    }
                })
                return promise2
            }
        }

        function resolvePromise(x, resolve, reject, promise2) {
            //å¤„ç†å¾ªç¯è°ƒç”¨
            if (x === promise2) {
                const err = new TypeError('Uncaught (in promsie) TypeError:detected for promise #&lt;Promsie&gt;')

                console.error(err)

                return reject(err)
            }
            //åˆ¤æ–­ x æ˜¯å¦æ˜¯ä¸€ä¸ªPromiseå¯¹è±¡
            if (x instanceof Promise) {
                // x.then((value) =&gt; {
                //     resolve(value)
                // }, err =&gt; {
                //     reject(err)
                // })

                //ç®€å†™
                x.then(resolve, reject)
            } else {
                resolve(x)
            }
        }
</code></pre>
<p>2ã€å°†thenä¸­çš„å‚æ•°å˜ä¸ºå¯é€‰<br>
<strong>é—®é¢˜ï¼š</strong><br>
ä¸Šé¢æˆ‘ä»¬å¤„ç† then æ–¹æ³•çš„æ—¶å€™éƒ½æ˜¯é»˜è®¤ä¼ å…¥ onFulfilledã€onRejected ä¸¤ä¸ªå›è°ƒå‡½æ•°ï¼Œä½†æ˜¯å®é™…ä¸ŠåŸç”Ÿ Promise æ˜¯å¯ä»¥é€‰æ‹©å‚æ•°çš„å•ä¼ æˆ–è€…ä¸ä¼ ï¼Œéƒ½ä¸ä¼šå½±å“æ‰§è¡Œ</p>
<pre><code>const promise = new Promise((resolve, reject) =&gt; {
  resolve(400)
})

promise.then().then(value =&gt; console.log(value))
</code></pre>
<p><strong>éœ€æ±‚ï¼š</strong><br>
â‘ é€šè¿‡åˆ¤æ–­è¯­å¥,å°†æ²¡æœ‰ä¼ å…¥å‚æ•°å˜ä¸ºé»˜è®¤å‡½æ•°</p>
<p>ç»¼ä¸Šï¼Œå†™å‡ºçš„thenæ–¹æ³•ä»£ç å¦‚ä¸‹ï¼š</p>
<pre><code>then(onFulfilled, onRejected) {
                if (typeof onFulfilled != 'function') {
                    onFulfilled = function (value) {
                        return value;
                    };
                }
                if (typeof onRejected != 'function') {
                    onRejected = function (reason) {
                        throw reason;
                    };
                }


                let promise2 = new Promise((resolve, reject) =&gt; {...
                return promise2
            }
</code></pre>
<p>3ã€å®ç°resolveå’Œrejectçš„é™æ€è°ƒç”¨</p>
<p>æ¯”è¾ƒç®€å•ï¼Œç›´æ¥ä¸Šä»£ç </p>
<pre><code>// resolve é™æ€æ–¹æ³•
        Promise.resolve = function(value) {
            // å¦‚æœä¼ å…¥ Promise å°±ç›´æ¥è¿”å›
            if (value instanceof Promise) {
                return value;
            }

            // è½¬æˆå¸¸è§„æ–¹å¼
            return new Promise(resolve =&gt; {
                resolve(value);
            });
        }

        // reject é™æ€æ–¹æ³•
        Promise.reject = function(reason) {
            return new Promise((resolve, reject) =&gt; {
                reject(reason);
            });
        }
        ```

        4ã€å‰©ä½™æ–¹æ³•

        â‘ finallyï¼š(æ¯”è¾ƒå°‘ç”¨)
        åŠŸèƒ½ï¼šæ— è®ºä¼ å…¥çš„æ˜¯resolveè¿˜æ˜¯rejectéƒ½ä¼šè¾“å‡º
        ```
        finally(fn) {
                return this.then(
                    (value) =&gt; {
                        fn();
                        return value;
                    },
                    (reason) =&gt; {
                        fn();
                        throw reason;
                    }
                );
            };
        ```

        â‘¡catchï¼š
        ```
        catch(onRejected) {
                return this.then(null, onRejected);
            };
        ```

        â‘¢allï¼š
        åŠŸèƒ½ï¼šæ¥å—ä¸€ä¸ªpromiseæ•°ç»„ï¼Œå½“æ‰€æœ‰promiseçŠ¶æ€resolveåï¼Œæ‰§è¡Œresolve
        ```
        Promise.all = function (promises) {
            return new Promise((resolve, reject) =&gt; {
                if (promises.length === 0) {
                    resolve([]);
                } else {
                    let result = [];
                    let index = 0;
                    for (let i = 0; i &lt; promises.length; i++) {
                        promises[i].then(
                            (data) =&gt; {
                                result[i] = data;
                                if (++index === promises.length) {
                                    resolve(result);
                                }
                            },
                            (err) =&gt; {
                                reject(err);
                                return;
                            }
                        );
                    }
                }
            });
        };
        ```

        â‘£raceï¼š
        åŠŸèƒ½ï¼šæ¥å—ä¸€ä¸ªpromiseæ•°ç»„ï¼Œå½“æœ‰ä¸€ä¸ªpromiseçŠ¶æ€resolveåï¼Œæ‰§è¡Œresolve(è°å¿«è°å…ˆæ‰§è¡Œ)
        ```
        Promise.race = function (promises) {
            return new Promise((resolve, reject) =&gt; {
                if (promises.length === 0) {
                    resolve();
                } else {
                    let index = 0;
                    for (let i = 0; i &lt; promises.length; i++) {
                        promises[i].then(
                            (data) =&gt; {
                                resolve(data);
                            },
                            (err) =&gt; {
                                reject(err);
                                return;
                            }
                        );
                    }
                }
            });
        };
        ```

        ä»¥ä¸Šï¼ŒPromiseçš„å¤§è‡´åŠŸèƒ½å°±å†™å®Œäº†ğŸ¤¤ğŸ¤¤ğŸ¤¤

        ä¸‹é¢æ˜¯æœ€åæ•´ç†å¥½çš„ä»£ç ï¼š
        ```
        class Promise {
            constructor(executor) {
                this.state = 'pending'

                this.value = null;
                this.reason = null;

                this.onResolvedCallbacks = [];
                this.onRejectedCallbacks = [];

                const resolve = (value) =&gt; {
                    if (this.state === 'pending') {
                        this.state = 'fulfilled';
                        this.value = value;
                        //éå†æ‰§è¡Œè°ƒç”¨æˆåŠŸçš„æ•°ç»„
                        this.onResolvedCallbacks.forEach(fn =&gt; fn()) //fn()å³ä¸ºå†…éƒ¨å­˜å‚¨çš„å‡½æ•°
                    }
                };

                const reject = (reason) =&gt; {
                    if (this.state === 'pending') {
                        this.state = 'rejected';
                        this.reason = reason;
                        //éå†æ‰§è¡Œè°ƒç”¨å¤±è´¥çš„æ•°ç»„
                        this.onRejectedCallbacks.forEach(fn =&gt; fn())
                    }
                };

                try {
                    executor(resolve, reject);
                } catch (reason) {
                    reject(reason);
                }
            }

            then(onFulfilled, onRejected) {
                if (typeof onFulfilled != 'function') {
                    onFulfilled = function (value) {
                        return value;
                    };
                }
                if (typeof onRejected != 'function') {
                    onRejected = function (reason) {
                        throw reason;
                    };
                }


                let promise2 = new Promise((resolve, reject) =&gt; {
                    //onFulfilledå¦‚æœæˆåŠŸäº†ï¼Œåº”è¯¥è¢«è°ƒç”¨
                    if (this.state === 'fulfilled') {
                        setTimeout(() =&gt; {
                            try {
                                //x æ˜¯onFulfilledæˆåŠŸçš„.thenå›è°ƒçš„è¿”å›å€¼
                                let x = onFulfilled(this.value)
                                //å¯¹xè¿›è¡Œåˆ†æ:
                                //1.å¦‚æœæ˜¯æ™®é€šå€¼ï¼Œç›´æ¥è°ƒç”¨resolve
                                //2.å¦‚æœæ˜¯promiseå¯¹è±¡ï¼Œçœ‹promiseæ˜¯å¦æˆåŠŸ

                                //å°†è¿”å›å€¼è¿”å›
                                resolvePromise(x, resolve, reject, promise2)
                            } catch (error) {
                                reject(error)
                            }

                        }, 0)

                    }
                    //onRejectedå¤±è´¥æˆåŠŸäº†ï¼Œåº”è¯¥è¢«è°ƒç”¨
                    if (this.state === 'rejected') {
                        setTimeout(() =&gt; {
                            try {
                                let x = onRejected(this.reason)
                                resolvePromise(x, resolve, reject, promise2)
                            } catch (error) {
                                reject(error)
                            }

                        }, 0)
                    }

                    if (this.state === 'pending') {
                        //å°†æˆåŠŸçš„æ—¶å€™è¦å¹²çš„äº‹å‚¨å­˜èµ·æ¥
                        this.onResolvedCallbacks.push(() =&gt; {
                            setTimeout(() =&gt; {
                                try {
                                    let x = onFulfilled(this.value)
                                    resolvePromise(x, resolve, reject, promise2)
                                } catch (error) {
                                    reject(error)
                                }

                            }, 0)
                        })
                        //å°†å¤±è´¥çš„æ—¶å€™è¦å¹²çš„äº‹å‚¨å­˜èµ·æ¥
                        this.onRejectedCallbacks.push(() =&gt; {
                            setTimeout(() =&gt; {
                                try {
                                    let x = onRejected(this.reason)
                                    resolvePromise(x, resolve, reject, promise2)
                                } catch (error) {
                                    reject(error)
                                }

                            }, 0)
                        })
                    }
                })
                return promise2
            }

            finally(fn) {
                return this.then(
                    (value) =&gt; {
                        fn();
                        return value;
                    },
                    (reason) =&gt; {
                        fn();
                        throw reason;
                    }
                );
            };

            catch (onRejected) {
                return this.then(null, onRejected);
            };
        }

        // resolve é™æ€æ–¹æ³•
        Promise.resolve = function (value) {
            // å¦‚æœä¼ å…¥ Promise å°±ç›´æ¥è¿”å›
            if (value instanceof Promise) {
                return value;
            }

            // è½¬æˆå¸¸è§„æ–¹å¼
            return new Promise(resolve =&gt; {
                resolve(value);
            });
        }

        // reject é™æ€æ–¹æ³•
        Promise.reject = function (reason) {
            return new Promise((resolve, reject) =&gt; {
                reject(reason);
            });
        }

        //æ¥å—ä¸€ä¸ªpromiseæ•°ç»„ï¼Œå½“æ‰€æœ‰promiseçŠ¶æ€resolveåï¼Œæ‰§è¡Œresolve
        Promise.all = function (promises) {
            return new Promise((resolve, reject) =&gt; {
                if (promises.length === 0) {
                    resolve([]);
                } else {
                    let result = [];
                    let index = 0;
                    for (let i = 0; i &lt; promises.length; i++) {
                        promises[i].then(
                            (data) =&gt; {
                                result[i] = data;
                                if (++index === promises.length) {
                                    resolve(result);
                                }
                            },
                            (err) =&gt; {
                                reject(err);
                                return;
                            }
                        );
                    }
                }
            });
        };

        //æ¥å—ä¸€ä¸ªpromiseæ•°ç»„ï¼Œå½“æœ‰ä¸€ä¸ªpromiseçŠ¶æ€resolveåï¼Œæ‰§è¡Œresolve
        Promise.race = function (promises) {
            return new Promise((resolve, reject) =&gt; {
                if (promises.length === 0) {
                    resolve();
                } else {
                    let index = 0;
                    for (let i = 0; i &lt; promises.length; i++) {
                        promises[i].then(
                            (data) =&gt; {
                                resolve(data);
                            },
                            (err) =&gt; {
                                reject(err);
                                return;
                            }
                        );
                    }
                }
            });
        };



        function resolvePromise(x, resolve, reject, promise2) {
            //å¤„ç†å¾ªç¯è°ƒç”¨
            if (x === promise2) {
                const err = new TypeError('Uncaught (in promsie) TypeError:detected for promise #&lt;Promsie&gt;')

                console.error(err)

                return reject(err)
            }
            //åˆ¤æ–­ x æ˜¯å¦æ˜¯ä¸€ä¸ªPromiseå¯¹è±¡
            if (x instanceof Promise) {
                // x.then((value) =&gt; {
                //     resolve(value)
                // }, err =&gt; {
                //     reject(err)
                // })

                //ç®€å†™
                x.then(resolve, reject)
            } else {
                resolve(x)
            }
        }
        ```
Promiseçš„æ‰‹å†™éƒ¨åˆ†åŸºæœ¬å¤§åŠŸå‘Šæˆ ğŸ‰ğŸ‰ğŸ‰
åœ¨åç»­è¿˜ä¼šé€šè¿‡ Promise A+ è§„èŒƒå¯¹æˆ‘ä»¬çš„ä»£ç è¿›è¡Œæ ¡éªŒï¼Œæ¥æ›´åŠ å®Œå–„æˆ‘ä»¬çš„ä»£ç ğŸ‘ŠğŸ‘ŠğŸ‘Š

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScriptä¸­çš„ç±»æ–¹æ³•ã€å¯¹è±¡æ–¹æ³•ã€åŸå‹æ–¹æ³•]]></title>
        <id>https://uaenaTzx.github.io/post/javascript-zhong-de-lei-fang-fa-dui-xiang-fang-fa-yuan-xing-fang-fa/</id>
        <link href="https://uaenaTzx.github.io/post/javascript-zhong-de-lei-fang-fa-dui-xiang-fang-fa-yuan-xing-fang-fa/">
        </link>
        <updated>2022-05-10T02:19:41.000Z</updated>
        <content type="html"><![CDATA[<p>å®šä¹‰ï¼š<br>
â‘ ç±»æ–¹æ³•ï¼šä¹Ÿå«å‡½æ•°æ–¹æ³•(åœ¨jsä¸­å¯ä»¥ä¸ºå‡½æ•°æ·»åŠ å±æ€§ä»¥åŠæ–¹æ³•)ï¼›<br>
â‘¡å¯¹è±¡æ–¹æ³•ï¼šåŒ…æ‹¬æ„é€ å‡½æ•°ä¸­çš„æ–¹æ³•ä»¥åŠå…¶åŸå‹ä¸Šé¢çš„æ–¹æ³•<font color="red">(å¯¹è±¡æ–¹æ³•åŒ…å«äº†åŸå‹æ–¹æ³•)ï¼›</font><br>
â‘¢åŸå‹æ–¹æ³•ï¼šä¸€èˆ¬ç”¨äºå¯¹è±¡å®ä¾‹å…±äº«ï¼Œä¸ºé¿å…å†…å­˜å¤ç”¨è€Œåœ¨åŸå‹ä¸Šæ·»åŠ æ–¹æ³•ï¼›</p>
<p><strong>jsä¸­çš„functionä½œä¸ºæ„é€ å‡½æ•°æ—¶ï¼Œè¢«è§†ä¸ºä¸€ä¸ªç±»ã€‚å¯ä»¥é€šè¿‡new xxxæ¥å¾—åˆ°ä¸€ä¸ªå®ä¾‹å¯¹è±¡</strong><br>
ä»¥ä¸‹æ˜¯ä¸€ä¸ªç¤ºä¾‹ä»£ç ï¼Œæ¥å˜æ¸…ä»¥ä¸Šä¸‰è€…çš„åŒºåˆ«ï¼š</p>
<pre><code>function People(name){ 
  this.name=name; 
  //å¯¹è±¡æ–¹æ³• (å®ä¾‹æ–¹æ³•)
  //æ¯ä¸ªå¯¹è±¡å®ä¾‹éƒ½æœ‰çš„æ–¹æ³•
  //åªæœ‰å¯¹è±¡å®ä¾‹æ‰èƒ½è°ƒç”¨çš„æ–¹æ³•
  this.Name=function(){
    console.log(&quot;My name is &quot;+this.name); 
  } 
} 
//ç±»æ–¹æ³• 
//åªæœ‰åŸå‹æ‰èƒ½è°ƒç”¨çš„æ–¹æ³•
People.Sleep=function(){ 
  console.log(&quot;People need sleep&quot;); 
} 
//åŸå‹æ–¹æ³• 
//æ‰€æœ‰å¯¹è±¡å®ä¾‹å…±äº«çš„æ–¹æ³•
//åŸå‹å¯é€šè¿‡People.prototype.learn()è°ƒç”¨
People.prototype.learn=function(){ 
  console.log('learning'); 
}
var Uaena =new People(&quot;Uaena&quot;); 
Uaena.Name();         //å¯¹è±¡æ–¹æ³•éœ€è¦é€šè¿‡å®ä¾‹åŒ–å¯¹è±¡å»è°ƒç”¨ 
People.Sleep();        //ç±»æ–¹æ³•ä¸éœ€è¦é€šè¿‡å®ä¾‹åŒ–å¯¹è±¡å»è°ƒç”¨ 
Uaena.learn();         //åŸå‹æ–¹æ³•éœ€è¦é€šè¿‡å®ä¾‹åŒ–å¯¹è±¡å»è°ƒç”¨
</code></pre>
]]></content>
    </entry>
</feed>