<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://uaenaTzx.github.io</id>
    <title>Uaena_blog</title>
    <updated>2022-05-16T09:05:23.121Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://uaenaTzx.github.io"/>
    <link rel="self" href="https://uaenaTzx.github.io/atom.xml"/>
    <subtitle>菜狗tzx的笔记博客🐕</subtitle>
    <logo>https://uaenaTzx.github.io/images/avatar.png</logo>
    <icon>https://uaenaTzx.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Uaena_blog</rights>
    <entry>
        <title type="html"><![CDATA[async、await函数的原理解析]]></title>
        <id>https://uaenaTzx.github.io/post/asyncawait-han-shu-de-yuan-li-jie-xi/</id>
        <link href="https://uaenaTzx.github.io/post/asyncawait-han-shu-de-yuan-li-jie-xi/">
        </link>
        <updated>2022-05-15T14:28:17.000Z</updated>
        <content type="html"><![CDATA[<h1 id="什么是async-await函数">什么是async、await函数</h1>
<p>简而言之，<code>async/await</code>是针对js异步问题的一种强有力的处理方法。</p>
<p>如果将<code>async</code>放在函数声明之前，则表明该函数是一个会返回<code>Promise</code>对象的异步函数。<br>
<code>await</code>必须和<code>async</code>一起使用<font color="red">（有<code>await</code>必有<code>async</code>，有<code>async</code>不一定有<code>await</code>！！！🌞）</font>。<br>
如果我们将<code>await</code>放在异步函数调用之前，则当代码执行到此处的时候，代码将会暂停，等到异步函数执行完成后，才会继续向下执行——<font color="red">这样就实现了异步函数的同步执行~</font></p>
<p>接下来我们用代码来演示一遍<code>async</code>和<code>await</code>的使用（红绿灯案例）</p>
<pre><code>        function timer(color, delay) {
            //返回一个Promise对象
            return new Promise((reslove, reject) =&gt; {
                console.log(color)
                setTimeout(() =&gt; {
                    reslove()
                }, delay)
            })
        }

        async function light() {
            await timer('green', 1000)
            await timer('yellow', 2000)
            await timer('red', 3000)

            await light()
        }
        light()
</code></pre>
<p>这样就实现了一个简单的的红绿灯系统，通过运行，我们可以发现整个函数是以同步的方式向下执行的。<br>
而要深究其中的原理，我们发现<code>Generator</code>函数可以实现这个过程</p>
<h1 id="什么是generator函数">什么是Generator函数</h1>
<p><code>Generator</code>函数是由ES6语法提供的一种异步编程解决方案。</p>
<p>如何理解<code>Generator</code>呢？<br>
<code>Generator</code>函数在自己的函数内部有多个“断点”，必须手动的调用next()方法才能执行下一步，这样的模式允许我们自如地去暂停/执行函数里面的代码(可以与“挤牙膏”进行类比)</p>
<p>下面我们来聊一下<code>Generator</code>函数的特征：</p>
<p>① function关键字和函数名之间有一个*<br>
(function* generatorDemo() {})<br>
② 内部使用<code>yield</code>进行状态控制<br>
③ 使用<code>next</code>执行下一步操作直到遇到<code>yield</code>关键字或者<code>return</code></p>
<p>我们通过简单的代码来展示一下</p>
<pre><code>function* generatorLight() {
        let value1 = yield 'green'
        let value2 = yield 'yellow'
        let value3 = yield 'red'
        console.log(value1 + ' ' + value2 +  ' ' + value3)
    }

    let light = generatorLight();
    console.log(light.next()) 
    console.log(light.next())
    console.log(light.next())
    console.log(light.next()) 
</code></pre>
<p>在上方代码中，我们调用<code>generatorLight()</code>并不是执行了该函数，而是返回了一个指向内部状态的<font color="red">指针对象</font>。通过<code>next()</code>方法来使指针指向下一个状态。</p>
<p>每一次next方法会返回一个对象：</p>
<pre><code>    {
        value: xxx
        done:  true/false //指针是否指向了函数末尾 即函数是否执行完毕
    },
</code></pre>
<p>其中，<code>value</code>代表<code>yield</code>后面表达式返回的值，如果遇到<code>return</code>，则将<code>return</code>后跟的表达式的值作为<code>value</code>的值。(如果函数没有<code>return</code>, 则<code>value</code>的值为<code>undefined</code>)<br>
<code>done</code>表示指针是否遍历完所有的<code>yield</code>对象，遇到<code>return</code>或者函数结束时，返回<code>true</code>(其余都为<code>false</code>)。</p>
<p>however，通过执行代码，我们可以发现<code>console.log(value1 + ' ' + value2 + ' ' + value3);</code>的输出结果是“undefined undefined undefined”。这是因为<code>yield</code>本身的返回值是<code>undefined</code>。 如果我们需要上一步的<code>yield</code>的返回值，我们需要将上一步的返回值传入<code>next()</code>中</p>
<pre><code>function* generatorLight() {
        let value1 = yield 'green'
        let value2 = yield 'yellow'
        let value3 = yield 'red'
        console.log(value1 + ' ' + value2 +  ' ' + value3)
    }

    let light = generatorLight()
    let res1 = light.next()
    let res2 = light.next(res1.value)
    let res3 = light.next(res2.value)
    light.next(res3.value)
</code></pre>
<p>这样就可以得到这样的结果：“green yellow red”</p>
<p>可是我们发现，<code>Generator</code>需要我们手动的去一次次执行，但刚刚实现的红绿灯系统却可以自动执行，为了让<code>Generator</code>也能够自动执行，我们应该引入<code>Thunk</code>函数的思想</p>
<h1 id="什么是thunk函数">什么是Thunk函数</h1>
<p><code>Thunk</code>函数是指将一个多参数函数替换成一个只接受<font color="red">回调函数</font>作为参数的单参数函数。</p>
<p>下面通过一个例子来体现<code>Thunk</code>函数的思想</p>
<pre><code> // 原函数
    readFile(fileName, callback)

    // thunk函数
    function thunk(fileName) {
        return function(callback) {
            return readFile(fileName, callback)
        }
    }

    let file = thunk('a.text')
    file(callback)
</code></pre>
<p>这个例子只是仅仅说明<code>thunk</code>的思想， 接下来我们要用<code>thunk</code>的思想来包装<code>Generator</code>函数，使它可以自动执行。</p>
<pre><code>         // Generator函数
        function* generatorLight() {
        let value1 = yield 'green'
        let value2 = yield 'yellow'
        let value3 = yield 'red'
        console.log(value1 + ' ' + value2 +  ' ' + value3)
    }

        // thunk包装
        function Thunk(fn) {
            const light = fn()

            function next(data) {
                let res = light.next(data)
                if (res.done) {
                    return res.value
                }
                next(res.value)
            }
            next(undefined)
        }

        Thunk(generatorLight)
</code></pre>
<p>我们在<code>Thunk</code>内部定义了一个<code>next</code>函数。通过递归来进行自动执行</p>
<h1 id="实现asyncawait">实现async/await</h1>
<p>接下来我们使用<code>Generator</code>函数来实现<code>async/await</code></p>
<p>首先，我们再来回顾一下之前的代码</p>
<pre><code>        function timer(color, delay) {
            //返回一个Promise对象
            return new Promise((reslove, reject) =&gt; {
                console.log(color)
                setTimeout(() =&gt; {
                    reslove()
                }, delay)
            })
        }

        async function light() {
            await timer('green', 1000)
            await timer('yellow', 2000)
            await timer('red', 3000)

            await light()
        }
        light()
</code></pre>
<p>我们先将<code>light</code>函数改造成<code>Generator</code>函数</p>
<pre><code>function* light() {
             yield timer('green', 1000)
             yield timer('yellow', 2000)
             yield timer('red', 3000)

             light()
        }
</code></pre>
<p>接着，我们再来实现<code>Thunk</code>函数</p>
<pre><code>   function Thunk(fn) {
       return new Promise((resolve, reject) =&gt; {
           const light = fn()
           function next(data) {
               let res = light.next(data)
               if (res.done) {
                   return resolve(res.value)
               }
               Promise.resolve(res.value).then(res =&gt; {
                   next(res)
               })
           }
           next(undefined)
       })
   }
</code></pre>
<p>到这里，我们就可以实现<code>async、await</code>的功能了，要注意的是，<font color="red"><code>light</code>的递归需要使用Thunk(light)!</font><br>
完整代码如下</p>
<pre><code>function timer(color, delay) {
            //返回一个Promise对象
            return new Promise((reslove, reject) =&gt; {
                console.log(color)
                setTimeout(() =&gt; {
                    reslove()
                }, delay)
            })
        }

       function* light() {
             yield timer('green', 1000)
             yield timer('yellow', 2000)
             yield timer('red', 3000)
             //light递归
             Thunk(light)
        }

    function Thunk(fn) {
       return new Promise((resolve, reject) =&gt; {
           const light = fn()
           function next(data) {
               let res = light.next(data)
               if (res.done) {
                   return resolve(res.value)
               }
               Promise.resolve(res.value).then(res =&gt; {
                   next(res)
               })
           }
           next(undefined)
       })
   }

   Thunk(light)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Promise手写]]></title>
        <id>https://uaenaTzx.github.io/post/Promise-handwriting/</id>
        <link href="https://uaenaTzx.github.io/post/Promise-handwriting/">
        </link>
        <updated>2022-05-10T04:12:08.000Z</updated>
        <content type="html"><![CDATA[<p>本篇开始手写Promise，从Promise类的基本构件开始</p>
<p>#一、基本构件</p>
<p><strong>需求：</strong><br>
①定义Promise对象，在构造函数中定义resolve和reject方法(用executor(resolve，reject)格式)<br>
②在构造函数中定义state参数，初始值为‘pending’，同时设有‘fulfiled’，‘rejected’共三种状态<br>
③在构造函数中定义value，reason参数，分别对应传入resolve和reject的值</p>
<p><strong>注意：</strong><br>
①Promise的state只能改变一次<br>
②应该使用try catch语法完善executor(resolve，reject)的执行</p>
<p>综上，写出的代码如下：</p>
<pre><code>class Promise {
            constructor(executor) {
                this.state = 'pending'

                this.value = null;//记录成功的值，给将来的.then()使用
                this.reason = null;//记录失败的值，给将来的.catch()使用

                const resolve = (value) =&gt; {
                    if (this.state === 'pending') {
                        this.state = 'fulfiled';
                        this.value = value;
                        
                    }
                };

                const reject = (reason) =&gt; {
                    if (this.state === 'pending') {
                        this.state = 'rejected';
                        this.reason = reason;
                        
                    }
                };

                try {
                    executor(resolve, reject);
                } catch (reason) {
                    reject(reason);
                }
            }
        }


        const p = new Promise((resolve, reject) =&gt; {
            //resolve和reject是Promise内部实现好的函数
            //这里的代码是立刻可执行的
            resolve(200)
        })

        p.then(res =&gt; {
            console.log(res);
        })
</code></pre>
<p>接下来我们来完善then()方法</p>
<p>#二、then()方法完善</p>
<p><strong>需求：</strong><br>
①传入onFulfiled，onRejected方法<br>
②用onFulfiled，onRejected接收p.then()传入的value和reason</p>
<p>综上，写出的代码如下：</p>
<pre><code>then(onFulfilled, onRejected) {
                //onFulfilled如果成功了，应该被调用
                if(this.state==='fulfilled'){
                    onFulfilled(this.value) 
                }
                //onRejected如果成功了，应该被调用
                if(this.state==='rejected'){
                    onRejected(this.reason)
                }

            }
</code></pre>
<p>接下来我们来解决异步问题</p>
<p>#三、异步问题解决</p>
<p><strong>问题：</strong><br>
当代码如下时：</p>
<pre><code>const p = new Promise((resolve, reject) =&gt; {
            setTimeout(() =&gt; {
                resolve(200)
            }, 1000)
        })

        p.then(res =&gt; {
            console.log(res);
        })
</code></pre>
<p>会遇到then()在state状态改变之前就执行，导致执行then()时的state仍然是pending状态</p>
<p><strong>需求：</strong><br>
①then()的执行不直接输出结果，而是将得到的数据先全部存放在两个数组中（成功和失败），在resolve或reject执行后再将数组中的函数输出<br>
②需要增加一个if判断state如果是pending，将数据存储在数组中<br>
③在resolve和reject方法中遍历两数组得到数据</p>
<p><strong>注意：</strong><font color="red">(这个真的很重要！！！🙉🙉🙉)</font><br>
①函数在数组中的存储需要用到函数的闭包(在函数的内部应用到外部的参数)——利用闭包将value或reason储存在函数中，并整合至数组</p>
<pre><code>//闭包
this.onResolvedCallbacks.push(() =&gt; {
                        onFulfilled(this.value)
                    })
//非闭包
this.onResolvedCallbacks.push(onFulfilled）
</code></pre>
<p>综上，写出的代码如下：</p>
<pre><code>class Promise {
            constructor(executor) {
                this.state = 'pending'

                this.value = null;
                this.reason = null;

                this.onResolvedCallbacks = [];
                this.onRejectedCallbacks = [];

                const resolve = (value) =&gt; {
                    if (this.state === 'pending') {
                        this.state = 'fulfiled';
                        this.value = value;
                        //遍历执行调用成功的数组
                        this.onResolvedCallbacks.forEach(fn =&gt; fn()) //fn()即为内部存储的函数
                    }
                };

                const reject = (reason) =&gt; {
                    if (this.state === 'pending') {
                        this.state = 'rejected';
                        this.reason = reason;
                        //遍历执行调用失败的数组
                        this.onRejectedCallbacks.forEach(fn =&gt; fn())
                    }
                };

                try {
                    executor(resolve, reject);
                } catch (reason) {
                    reject(reason);
                }
            }

            then(onFulfilled, onRejected) {
                //onFulfilled如果成功了，应该被调用
                if (this.state === 'fulfilled') {
                    onFulfilled(this.value)
                }
                //onRejected如果成功了，应该被调用
                if (this.state === 'rejected') {
                    onRejected(this.reason)
                }

                if (this.state === 'pending') {
                    //将成功的时候要干的事储存起来
                    this.onResolvedCallbacks.push(() =&gt; {
                        onFulfilled(this.value)
                    })
                    //将失败的时候要干的事储存起来
                    this.onRejectedCallbacks.push(() =&gt; {
                        onRejected(this.reason)
                    })
                }

            }
        }


        const p = new Promise((resolve, reject) =&gt; {
            //resolve和reject是Promise内部实现好的函数
            //这里的代码是立刻可执行的
            setTimeout(() =&gt; {
                resolve(200)
            }, 1000)

        })

        p.then(res =&gt; {
            console.log(res,'1');
        })

        p.then(res =&gt; {
            console.log(res,'2');
        })

        p.then(res =&gt; {
            console.log(res,'3');
        })
</code></pre>
<p>得到以下结果(1s后)：</p>
<blockquote>
<p>200 '1'<br>
200 '2'<br>
200 '3'</p>
</blockquote>
<p>接下来我们来处理链式问题</p>
<p>#四、链式问题解决</p>
<p><strong>需求：</strong><br>
①上一个.then要返回一个promise对象<br>
②下一个.then的参数，要拿到上一个.then的回调返回值<br>
③设置参数x为onFulfilled成功的.then回调的返回值，并通过resolve(x)来进行链式操作</p>
<p><strong>注意：</strong><font color="red">(真的很绕，好好理解一下🤡)</font><br>
①代码运用了递归的思想，上一级then返回Promsie对象来延续下一级的then，因此需要在then函数中构造一个新的Promise对象并返回，在新的Promise对象中通过当前阶段的回调函数值决定下一步操作<br>
②x可能是传入的普通值，也可能是Promise对象，因此要用一个函数来判断x的类型并进行相应的处理</p>
<p>综上，写出的代码如下：</p>
<pre><code>class Promise {
            constructor(executor) {
                this.state = 'pending'

                this.value = null;
                this.reason = null;

                this.onResolvedCallbacks = [];
                this.onRejectedCallbacks = [];

                const resolve = (value) =&gt; {
                    if (this.state === 'pending') {
                        this.state = 'fulfilled';
                        this.value = value;
                        //遍历执行调用成功的数组
                        this.onResolvedCallbacks.forEach(fn =&gt; fn()) //fn()即为内部存储的函数
                    }
                };

                const reject = (reason) =&gt; {
                    if (this.state === 'pending') {
                        this.state = 'rejected';
                        this.reason = reason;
                        //遍历执行调用失败的数组
                        this.onRejectedCallbacks.forEach(fn =&gt; fn())
                    }
                };

                try {
                    executor(resolve, reject);
                } catch (reason) {
                    reject(reason);
                }
            }

            then(onFulfilled, onRejected) {
                let promise2 = new Promise((resolve, reject) =&gt; {
                    //onFulfilled如果成功了，应该被调用
                    if (this.state === 'fulfilled') {
                        //x 是onFulfilled成功的.then回调的返回值
                        let x = onFulfilled(this.value)
                        //对x进行分析:
                        //1.如果是普通值，直接调用resolve
                        //2.如果是promise对象，看promise是否成功

                        //将返回值返回
                        resolvePromise(x, resolve, reject)
                    }
                    //onRejected如果成功了，应该被调用
                    if (this.state === 'rejected') {
                        onRejected(this.reason)
                        let x = onRejected(this.reason)
                        reject(x)
                    }

                    if (this.state === 'pending') {
                        //将成功的时候要干的事储存起来
                        this.onResolvedCallbacks.push(() =&gt; {
                            onFulfilled(this.value)
                        })
                        //将失败的时候要干的事储存起来
                        this.onRejectedCallbacks.push(() =&gt; {
                            onRejected(this.reason)
                        })
                    }
                })
                return promise2
            }
        }

        function resolvePromise(x, resolve, reject) {
            //判断 x 是否是一个Promise对象
            if (x instanceof Promise) {
                // x.then((value) =&gt; {
                //     resolve(value)
                // }, err =&gt; {
                //     reject(err)
                // })

                //简写
                x.then(resolve,reject)
            } else {
                resolve(x)
            }
        }

        const p = new Promise((resolve, reject) =&gt; {
            //resolve和reject是Promise内部实现好的函数
            //这里的代码是立刻可执行的
            resolve(400)

        })

        p.then(res =&gt; {
            console.log(res);
            return new Promise((resolve, reject) =&gt; {
                resolve(200)
            })
        }).then(data =&gt; {
            console.log(data);
        })
</code></pre>
<p>得到以下结果：</p>
<blockquote>
<p>400<br>
200</p>
</blockquote>
<p>接下来我们来完善Promise其他剩余的内容：</p>
<p>#五、剩余内容完善</p>
<p>1、循环调用&amp;&amp;异常捕获<br>
<strong>问题：</strong></p>
<pre><code>const p = new Promise((resolve, reject) =&gt; {
            resolve(400)
        })

const p2 = p.then((data)=&gt;{
            console.log(data);
            return p2
        })
</code></pre>
<p>其中，第一个p2等价于promise2，第二个p2等价于x(promise2,x的定义详见前文),显然promise2不可能等于x<br>
<strong>需求：</strong><br>
①通过判断语句来解决以上矛盾(写在resolvePromsie和rejectPromsie中)<br>
②使用<em>try catch</em>语法来捕获错误</p>
<p><strong>注意：</strong><br>
①由于resolvePromsie和rejectPromsie写在promise2的内部，因此导入方法的promise2是不准确的，<em>此处需要使用异步操作（setTimeout（（）=&gt;{},0））来解决问题</em></p>
<p>综上，写出的代码如下：</p>
<pre><code>class Promise {
            constructor(executor) {
                this.state = 'pending'

                this.value = null;
                this.reason = null;

                this.onResolvedCallbacks = [];
                this.onRejectedCallbacks = [];

                const resolve = (value) =&gt; {
                    if (this.state === 'pending') {
                        this.state = 'fulfilled';
                        this.value = value;
                        //遍历执行调用成功的数组
                        this.onResolvedCallbacks.forEach(fn =&gt; fn()) //fn()即为内部存储的函数
                    }
                };

                const reject = (reason) =&gt; {
                    if (this.state === 'pending') {
                        this.state = 'rejected';
                        this.reason = reason;
                        //遍历执行调用失败的数组
                        this.onRejectedCallbacks.forEach(fn =&gt; fn())
                    }
                };

                try {
                    executor(resolve, reject);
                } catch (reason) {
                    reject(reason);
                }
            }

            then(onFulfilled, onRejected) {
                let promise2 = new Promise((resolve, reject) =&gt; {
                    //onFulfilled如果成功了，应该被调用
                    if (this.state === 'fulfilled') {
                        setTimeout(() =&gt; {
                            try {
                                //x 是onFulfilled成功的.then回调的返回值
                                let x = onFulfilled(this.value)
                                //对x进行分析:
                                //1.如果是普通值，直接调用resolve
                                //2.如果是promise对象，看promise是否成功

                                //将返回值返回
                                resolvePromise(x, resolve, reject, promise2)
                            } catch (error) {
                                reject(error)
                            }

                        }, 0)

                    }
                    //onRejected失败成功了，应该被调用
                    if (this.state === 'rejected') {
                        setTimeout(() =&gt; {
                            try {
                                let x = onRejected(this.reason)
                                resolvePromise(x, resolve, reject, promise2)
                            } catch (error) {
                                reject(error)
                            }

                        }, 0)
                    }

                    if (this.state === 'pending') {
                        //将成功的时候要干的事储存起来
                        this.onResolvedCallbacks.push(() =&gt; {
                            setTimeout(() =&gt; {
                                try {
                                    let x = onFulfilled(this.value)
                                    resolvePromise(x, resolve, reject, promise2)
                                } catch (error) {
                                    reject(error)
                                }

                            }, 0)
                        })
                        //将失败的时候要干的事储存起来
                        this.onRejectedCallbacks.push(() =&gt; {
                            setTimeout(() =&gt; {
                                try {
                                    let x = onRejected(this.reason)
                                    resolvePromise(x, resolve, reject, promise2)
                                } catch (error) {
                                    reject(error)
                                }

                            }, 0)
                        })
                    }
                })
                return promise2
            }
        }

        function resolvePromise(x, resolve, reject, promise2) {
            //处理循环调用
            if (x === promise2) {
                const err = new TypeError('Uncaught (in promsie) TypeError:detected for promise #&lt;Promsie&gt;')

                console.error(err)

                return reject(err)
            }
            //判断 x 是否是一个Promise对象
            if (x instanceof Promise) {
                // x.then((value) =&gt; {
                //     resolve(value)
                // }, err =&gt; {
                //     reject(err)
                // })

                //简写
                x.then(resolve, reject)
            } else {
                resolve(x)
            }
        }
</code></pre>
<p>2、将then中的参数变为可选<br>
<strong>问题：</strong><br>
上面我们处理 then 方法的时候都是默认传入 onFulfilled、onRejected 两个回调函数，但是实际上原生 Promise 是可以选择参数的单传或者不传，都不会影响执行</p>
<pre><code>const promise = new Promise((resolve, reject) =&gt; {
  resolve(400)
})

promise.then().then(value =&gt; console.log(value))
</code></pre>
<p><strong>需求：</strong><br>
①通过判断语句,将没有传入参数变为默认函数</p>
<p>综上，写出的then方法代码如下：</p>
<pre><code>then(onFulfilled, onRejected) {
                if (typeof onFulfilled != 'function') {
                    onFulfilled = function (value) {
                        return value;
                    };
                }
                if (typeof onRejected != 'function') {
                    onRejected = function (reason) {
                        throw reason;
                    };
                }


                let promise2 = new Promise((resolve, reject) =&gt; {...
                return promise2
            }
</code></pre>
<p>3、实现resolve和reject的静态调用</p>
<p>比较简单，直接上代码</p>
<pre><code>// resolve 静态方法
        Promise.resolve = function(value) {
            // 如果传入 Promise 就直接返回
            if (value instanceof Promise) {
                return value;
            }

            // 转成常规方式
            return new Promise(resolve =&gt; {
                resolve(value);
            });
        }

        // reject 静态方法
        Promise.reject = function(reason) {
            return new Promise((resolve, reject) =&gt; {
                reject(reason);
            });
        }
        ```

        4、剩余方法

        ①finally：(比较少用)
        功能：无论传入的是resolve还是reject都会输出
        ```
        finally(fn) {
                return this.then(
                    (value) =&gt; {
                        fn();
                        return value;
                    },
                    (reason) =&gt; {
                        fn();
                        throw reason;
                    }
                );
            };
        ```

        ②catch：
        ```
        catch(onRejected) {
                return this.then(null, onRejected);
            };
        ```

        ③all：
        功能：接受一个promise数组，当所有promise状态resolve后，执行resolve
        ```
        Promise.all = function (promises) {
            return new Promise((resolve, reject) =&gt; {
                if (promises.length === 0) {
                    resolve([]);
                } else {
                    let result = [];
                    let index = 0;
                    for (let i = 0; i &lt; promises.length; i++) {
                        promises[i].then(
                            (data) =&gt; {
                                result[i] = data;
                                if (++index === promises.length) {
                                    resolve(result);
                                }
                            },
                            (err) =&gt; {
                                reject(err);
                                return;
                            }
                        );
                    }
                }
            });
        };
        ```

        ④race：
        功能：接受一个promise数组，当有一个promise状态resolve后，执行resolve(谁快谁先执行)
        ```
        Promise.race = function (promises) {
            return new Promise((resolve, reject) =&gt; {
                if (promises.length === 0) {
                    resolve();
                } else {
                    let index = 0;
                    for (let i = 0; i &lt; promises.length; i++) {
                        promises[i].then(
                            (data) =&gt; {
                                resolve(data);
                            },
                            (err) =&gt; {
                                reject(err);
                                return;
                            }
                        );
                    }
                }
            });
        };
        ```

        以上，Promise的大致功能就写完了🤤🤤🤤

        下面是最后整理好的代码：
        ```
        class Promise {
            constructor(executor) {
                this.state = 'pending'

                this.value = null;
                this.reason = null;

                this.onResolvedCallbacks = [];
                this.onRejectedCallbacks = [];

                const resolve = (value) =&gt; {
                    if (this.state === 'pending') {
                        this.state = 'fulfilled';
                        this.value = value;
                        //遍历执行调用成功的数组
                        this.onResolvedCallbacks.forEach(fn =&gt; fn()) //fn()即为内部存储的函数
                    }
                };

                const reject = (reason) =&gt; {
                    if (this.state === 'pending') {
                        this.state = 'rejected';
                        this.reason = reason;
                        //遍历执行调用失败的数组
                        this.onRejectedCallbacks.forEach(fn =&gt; fn())
                    }
                };

                try {
                    executor(resolve, reject);
                } catch (reason) {
                    reject(reason);
                }
            }

            then(onFulfilled, onRejected) {
                if (typeof onFulfilled != 'function') {
                    onFulfilled = function (value) {
                        return value;
                    };
                }
                if (typeof onRejected != 'function') {
                    onRejected = function (reason) {
                        throw reason;
                    };
                }


                let promise2 = new Promise((resolve, reject) =&gt; {
                    //onFulfilled如果成功了，应该被调用
                    if (this.state === 'fulfilled') {
                        setTimeout(() =&gt; {
                            try {
                                //x 是onFulfilled成功的.then回调的返回值
                                let x = onFulfilled(this.value)
                                //对x进行分析:
                                //1.如果是普通值，直接调用resolve
                                //2.如果是promise对象，看promise是否成功

                                //将返回值返回
                                resolvePromise(x, resolve, reject, promise2)
                            } catch (error) {
                                reject(error)
                            }

                        }, 0)

                    }
                    //onRejected失败成功了，应该被调用
                    if (this.state === 'rejected') {
                        setTimeout(() =&gt; {
                            try {
                                let x = onRejected(this.reason)
                                resolvePromise(x, resolve, reject, promise2)
                            } catch (error) {
                                reject(error)
                            }

                        }, 0)
                    }

                    if (this.state === 'pending') {
                        //将成功的时候要干的事储存起来
                        this.onResolvedCallbacks.push(() =&gt; {
                            setTimeout(() =&gt; {
                                try {
                                    let x = onFulfilled(this.value)
                                    resolvePromise(x, resolve, reject, promise2)
                                } catch (error) {
                                    reject(error)
                                }

                            }, 0)
                        })
                        //将失败的时候要干的事储存起来
                        this.onRejectedCallbacks.push(() =&gt; {
                            setTimeout(() =&gt; {
                                try {
                                    let x = onRejected(this.reason)
                                    resolvePromise(x, resolve, reject, promise2)
                                } catch (error) {
                                    reject(error)
                                }

                            }, 0)
                        })
                    }
                })
                return promise2
            }

            finally(fn) {
                return this.then(
                    (value) =&gt; {
                        fn();
                        return value;
                    },
                    (reason) =&gt; {
                        fn();
                        throw reason;
                    }
                );
            };

            catch (onRejected) {
                return this.then(null, onRejected);
            };
        }

        // resolve 静态方法
        Promise.resolve = function (value) {
            // 如果传入 Promise 就直接返回
            if (value instanceof Promise) {
                return value;
            }

            // 转成常规方式
            return new Promise(resolve =&gt; {
                resolve(value);
            });
        }

        // reject 静态方法
        Promise.reject = function (reason) {
            return new Promise((resolve, reject) =&gt; {
                reject(reason);
            });
        }

        //接受一个promise数组，当所有promise状态resolve后，执行resolve
        Promise.all = function (promises) {
            return new Promise((resolve, reject) =&gt; {
                if (promises.length === 0) {
                    resolve([]);
                } else {
                    let result = [];
                    let index = 0;
                    for (let i = 0; i &lt; promises.length; i++) {
                        promises[i].then(
                            (data) =&gt; {
                                result[i] = data;
                                if (++index === promises.length) {
                                    resolve(result);
                                }
                            },
                            (err) =&gt; {
                                reject(err);
                                return;
                            }
                        );
                    }
                }
            });
        };

        //接受一个promise数组，当有一个promise状态resolve后，执行resolve
        Promise.race = function (promises) {
            return new Promise((resolve, reject) =&gt; {
                if (promises.length === 0) {
                    resolve();
                } else {
                    let index = 0;
                    for (let i = 0; i &lt; promises.length; i++) {
                        promises[i].then(
                            (data) =&gt; {
                                resolve(data);
                            },
                            (err) =&gt; {
                                reject(err);
                                return;
                            }
                        );
                    }
                }
            });
        };



        function resolvePromise(x, resolve, reject, promise2) {
            //处理循环调用
            if (x === promise2) {
                const err = new TypeError('Uncaught (in promsie) TypeError:detected for promise #&lt;Promsie&gt;')

                console.error(err)

                return reject(err)
            }
            //判断 x 是否是一个Promise对象
            if (x instanceof Promise) {
                // x.then((value) =&gt; {
                //     resolve(value)
                // }, err =&gt; {
                //     reject(err)
                // })

                //简写
                x.then(resolve, reject)
            } else {
                resolve(x)
            }
        }
        ```
Promise的手写部分基本大功告成 🎉🎉🎉
在后续还会通过 Promise A+ 规范对我们的代码进行校验，来更加完善我们的代码👊👊👊

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript中的类方法、对象方法、原型方法]]></title>
        <id>https://uaenaTzx.github.io/post/javascript-zhong-de-lei-fang-fa-dui-xiang-fang-fa-yuan-xing-fang-fa/</id>
        <link href="https://uaenaTzx.github.io/post/javascript-zhong-de-lei-fang-fa-dui-xiang-fang-fa-yuan-xing-fang-fa/">
        </link>
        <updated>2022-05-10T02:19:41.000Z</updated>
        <content type="html"><![CDATA[<p>定义：<br>
①类方法：也叫函数方法(在js中可以为函数添加属性以及方法)；<br>
②对象方法：包括构造函数中的方法以及其原型上面的方法<font color="red">(对象方法包含了原型方法)；</font><br>
③原型方法：一般用于对象实例共享，为避免内存复用而在原型上添加方法；</p>
<p><strong>js中的function作为构造函数时，被视为一个类。可以通过new xxx来得到一个实例对象</strong><br>
以下是一个示例代码，来厘清以上三者的区别：</p>
<pre><code>function People(name){ 
  this.name=name; 
  //对象方法 (实例方法)
  //每个对象实例都有的方法
  //只有对象实例才能调用的方法
  this.Name=function(){
    console.log(&quot;My name is &quot;+this.name); 
  } 
} 
//类方法 
//只有原型才能调用的方法
People.Sleep=function(){ 
  console.log(&quot;People need sleep&quot;); 
} 
//原型方法 
//所有对象实例共享的方法
//原型可通过People.prototype.learn()调用
People.prototype.learn=function(){ 
  console.log('learning'); 
}
var Uaena =new People(&quot;Uaena&quot;); 
Uaena.Name();         //对象方法需要通过实例化对象去调用 
People.Sleep();        //类方法不需要通过实例化对象去调用 
Uaena.learn();         //原型方法需要通过实例化对象去调用
</code></pre>
]]></content>
    </entry>
</feed>