<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://uaenaTzx.github.io</id>
    <title>Uaena_blog</title>
    <updated>2022-05-10T12:46:11.736Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://uaenaTzx.github.io"/>
    <link rel="self" href="https://uaenaTzx.github.io/atom.xml"/>
    <subtitle>菜狗tzx的笔记博客🐕</subtitle>
    <logo>https://uaenaTzx.github.io/images/avatar.png</logo>
    <icon>https://uaenaTzx.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Uaena_blog</rights>
    <entry>
        <title type="html"><![CDATA[Promise手写(5)——其他方法完善]]></title>
        <id>https://uaenaTzx.github.io/post/promise-shou-xie-5-qi-ta-fang-fa-wan-shan/</id>
        <link href="https://uaenaTzx.github.io/post/promise-shou-xie-5-qi-ta-fang-fa-wan-shan/">
        </link>
        <updated>2022-05-10T06:32:04.000Z</updated>
        <content type="html"><![CDATA[<p>接下来我们来完善Promise其他剩余的内容</p>
<p><strong>需求：</strong></p>
<p><strong>注意：</strong></p>
<p>综上，写出的代码如下：</p>
<pre><code></code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Promise手写(4)——处理链式&&循环调用问题]]></title>
        <id>https://uaenaTzx.github.io/post/promise-shou-xie-4-chu-li-lian-shi-andxun-huan-diao-yong-wen-ti/</id>
        <link href="https://uaenaTzx.github.io/post/promise-shou-xie-4-chu-li-lian-shi-andxun-huan-diao-yong-wen-ti/">
        </link>
        <updated>2022-05-10T06:31:08.000Z</updated>
        <content type="html"><![CDATA[<p>接下来我们来处理链式问题和循环调用问题</p>
<p><strong>需求：</strong><br>
①上一个.then要返回一个promise对象<br>
②下一个.then的参数，要拿到上一个.then的回调返回值<br>
③设置参数x为onFulfilled成功的.then回调的返回值，并通过resolve(x)来进行链式操作</p>
<p><strong>注意：</strong><font color="red">(真的很绕，好好理解一下🤡)</font><br>
①代码运用了递归的思想，上一级then返回Promsie对象来延续下一级的then，因此需要在then函数中构造一个新的Promise对象并返回，在新的Promise对象中通过当前阶段的回调函数值决定下一步操作</p>
<p>综上，写出的代码如下：</p>
<pre><code>class Promise {
            constructor(executor) {
                this.state = 'pending'

                this.value = null;
                this.reason = null;

                this.onResolvedCallbacks = [];
                this.onRejectedCallbacks = [];

                const resolve = (value) =&gt; {
                    if (this.state === 'pending') {
                        this.state = 'fulfilled';
                        this.value = value;
                        //遍历执行调用成功的数组
                        this.onResolvedCallbacks.forEach(fn =&gt; fn()) //fn()即为内部存储的函数
                    }
                };

                const reject = (reason) =&gt; {
                    if (this.state === 'pending') {
                        this.state = 'rejected';
                        this.reason = reason;
                        //遍历执行调用失败的数组
                        this.onRejectedCallbacks.forEach(fn =&gt; fn())
                    }
                };

                try {
                    executor(resolve, reject);
                } catch (reason) {
                    reject(reason);
                }
            }

            then(onFulfilled, onRejected) {
                let promise2 = new Promise((resolve, reject) =&gt; {
                    //onFulfilled如果成功了，应该被调用
                    if (this.state === 'fulfilled') {
                        //x 是onFulfilled成功的.then回调的返回值
                        let x = onFulfilled(this.value)
                        //将返回值返回
                        resolve(x)
                    }
                    //onRejected如果成功了，应该被调用
                    if (this.state === 'rejected') {
                        onRejected(this.reason)
                        let x = onRejected(this.reason)
                        reject(x)
                    }

                    if (this.state === 'pending') {
                        //将成功的时候要干的事储存起来
                        this.onResolvedCallbacks.push(() =&gt; {
                            onFulfilled(this.value)
                        })
                        //将失败的时候要干的事储存起来
                        this.onRejectedCallbacks.push(() =&gt; {
                            onRejected(this.reason)
                        })
                    }
                })
                return promise2
            }
        }


        const p = new Promise((resolve, reject) =&gt; {
            //resolve和reject是Promise内部实现好的函数
            //这里的代码是立刻可执行的
            resolve(400)

        })

        p.then(res =&gt; {
            console.log(res);
            return 200
            //内部转化为resolve(200)
        }).then(data =&gt; {
            console.log(data);
        })
</code></pre>
<p>得到以下结果：</p>
<blockquote>
<p>400<br>
200</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Promise手写(3)——异步问题解决]]></title>
        <id>https://uaenaTzx.github.io/post/promise-shou-xie-3-yi-bu-wen-ti-jie-jue/</id>
        <link href="https://uaenaTzx.github.io/post/promise-shou-xie-3-yi-bu-wen-ti-jie-jue/">
        </link>
        <updated>2022-05-10T06:30:23.000Z</updated>
        <content type="html"><![CDATA[<p>接下来我们来解决异步问题</p>
<p><strong>问题：</strong><br>
当代码如下时：</p>
<pre><code>const p = new Promise((resolve, reject) =&gt; {
            setTimeout(() =&gt; {
                resolve(200)
            }, 1000)
        })

        p.then(res =&gt; {
            console.log(res);
        })
</code></pre>
<p>会遇到then()在state状态改变之前就执行，导致执行then()时的state仍然是pending状态</p>
<p><strong>需求：</strong><br>
①then()的执行不直接输出结果，而是将得到的数据先全部存放在两个数组中（成功和失败），在resolve或reject执行后再将数组中的函数输出<br>
②需要增加一个if判断state如果是pending，将数据存储在数组中<br>
③在resolve和reject方法中遍历两数组得到数据</p>
<p><strong>注意：</strong><font color="red">(这个真的很重要！！！🙉🙉🙉)</font><br>
①函数在数组中的存储需要用到函数的闭包(在函数的内部应用到外部的参数)——利用闭包将value或reason储存在函数中，并整合至数组</p>
<pre><code>//闭包
this.onResolvedCallbacks.push(() =&gt; {
                        onFulfilled(this.value)
                    })
//非闭包
this.onResolvedCallbacks.push(onFulfilled）
</code></pre>
<p>综上，写出的代码如下：</p>
<pre><code>class Promise {
            constructor(executor) {
                this.state = 'pending'

                this.value = null;
                this.reason = null;

                this.onResolvedCallbacks = [];
                this.onRejectedCallbacks = [];

                const resolve = (value) =&gt; {
                    if (this.state === 'pending') {
                        this.state = 'fulfiled';
                        this.value = value;
                        //遍历执行调用成功的数组
                        this.onResolvedCallbacks.forEach(fn =&gt; fn()) //fn()即为内部存储的函数
                    }
                };

                const reject = (reason) =&gt; {
                    if (this.state === 'pending') {
                        this.state = 'rejected';
                        this.reason = reason;
                        //遍历执行调用失败的数组
                        this.onRejectedCallbacks.forEach(fn =&gt; fn())
                    }
                };

                try {
                    executor(resolve, reject);
                } catch (reason) {
                    reject(reason);
                }
            }

            then(onFulfilled, onRejected) {
                //onFulfilled如果成功了，应该被调用
                if (this.state === 'fulfilled') {
                    onFulfilled(this.value)
                }
                //onRejected如果成功了，应该被调用
                if (this.state === 'rejected') {
                    onRejected(this.reason)
                }

                if (this.state === 'pending') {
                    //将成功的时候要干的事储存起来
                    this.onResolvedCallbacks.push(() =&gt; {
                        onFulfilled(this.value)
                    })
                    //将失败的时候要干的事储存起来
                    this.onRejectedCallbacks.push(() =&gt; {
                        onRejected(this.reason)
                    })
                }

            }
        }


        const p = new Promise((resolve, reject) =&gt; {
            //resolve和reject是Promise内部实现好的函数
            //这里的代码是立刻可执行的
            setTimeout(() =&gt; {
                resolve(200)
            }, 1000)

        })

        p.then(res =&gt; {
            console.log(res,'1');
        })

        p.then(res =&gt; {
            console.log(res,'2');
        })

        p.then(res =&gt; {
            console.log(res,'3');
        })
</code></pre>
<p>得到以下结果(1s后)：</p>
<blockquote>
<p>200 '1'<br>
200 '2'<br>
200 '3'</p>
</blockquote>
]]></content>
    </entry>
</feed>