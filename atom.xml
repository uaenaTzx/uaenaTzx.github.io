<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://uaenaTzx.github.io</id>
    <title>Uaena_blog</title>
    <updated>2022-05-11T06:02:46.166Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://uaenaTzx.github.io"/>
    <link rel="self" href="https://uaenaTzx.github.io/atom.xml"/>
    <subtitle>èœç‹—tzxçš„ç¬”è®°åšå®¢ğŸ•</subtitle>
    <logo>https://uaenaTzx.github.io/images/avatar.png</logo>
    <icon>https://uaenaTzx.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Uaena_blog</rights>
    <entry>
        <title type="html"><![CDATA[Promiseæ‰‹å†™â­â­â­â­â­]]></title>
        <id>https://uaenaTzx.github.io/post/Promise-handwriting/</id>
        <link href="https://uaenaTzx.github.io/post/Promise-handwriting/">
        </link>
        <updated>2022-05-10T04:12:08.000Z</updated>
        <content type="html"><![CDATA[<p>æœ¬ç¯‡å¼€å§‹æ‰‹å†™Promiseï¼Œä»Promiseç±»çš„åŸºæœ¬æ„ä»¶å¼€å§‹</p>
<p>#ä¸€ã€åŸºæœ¬æ„ä»¶</p>
<p><strong>éœ€æ±‚ï¼š</strong><br>
â‘ å®šä¹‰Promiseå¯¹è±¡ï¼Œåœ¨æ„é€ å‡½æ•°ä¸­å®šä¹‰resolveå’Œrejectæ–¹æ³•(ç”¨*executorï¼ˆresolveï¼Œrejectï¼‰*æ ¼å¼)<br>
â‘¡åœ¨æ„é€ å‡½æ•°ä¸­å®šä¹‰stateå‚æ•°ï¼Œåˆå§‹å€¼ä¸ºâ€˜pendingâ€™ï¼ŒåŒæ—¶è®¾æœ‰â€˜fulfiledâ€™ï¼Œâ€˜rejectedâ€™å…±ä¸‰ç§çŠ¶æ€<br>
â‘¢åœ¨æ„é€ å‡½æ•°ä¸­å®šä¹‰valueï¼Œreasonå‚æ•°ï¼Œåˆ†åˆ«å¯¹åº”ä¼ å…¥resolveå’Œrejectçš„å€¼</p>
<p><strong>æ³¨æ„ï¼š</strong><br>
â‘ Promiseçš„stateåªèƒ½æ”¹å˜ä¸€æ¬¡<br>
â‘¡åº”è¯¥ä½¿ç”¨try catchè¯­æ³•å®Œå–„*executorï¼ˆresolveï¼Œrejectï¼‰*çš„æ‰§è¡Œ</p>
<p>ç»¼ä¸Šï¼Œå†™å‡ºçš„ä»£ç å¦‚ä¸‹ï¼š</p>
<pre><code>class Promise {
            constructor(executor) {
                this.state = 'pending'

                this.value = null;//è®°å½•æˆåŠŸçš„å€¼ï¼Œç»™å°†æ¥çš„.then()ä½¿ç”¨
                this.reason = null;//è®°å½•å¤±è´¥çš„å€¼ï¼Œç»™å°†æ¥çš„.catch()ä½¿ç”¨

                const resolve = (value) =&gt; {
                    if (this.state === 'pending') {
                        this.state = 'fulfiled';
                        this.value = value;
                        
                    }
                };

                const reject = (reason) =&gt; {
                    if (this.state === 'pending') {
                        this.state = 'rejected';
                        this.reason = reason;
                        
                    }
                };

                try {
                    executor(resolve, reject);
                } catch (reason) {
                    reject(reason);
                }
            }
        }


        const p = new Promise((resolve, reject) =&gt; {
            //resolveå’Œrejectæ˜¯Promiseå†…éƒ¨å®ç°å¥½çš„å‡½æ•°
            //è¿™é‡Œçš„ä»£ç æ˜¯ç«‹åˆ»å¯æ‰§è¡Œçš„
            resolve(200)
        })

        p.then(res =&gt; {
            console.log(res);
        })
</code></pre>
<p>æ¥ä¸‹æ¥æˆ‘ä»¬æ¥å®Œå–„then()æ–¹æ³•</p>
<p>#äºŒã€then()æ–¹æ³•å®Œå–„</p>
<p><strong>éœ€æ±‚ï¼š</strong><br>
â‘ ä¼ å…¥onFulfiledï¼ŒonRejectedæ–¹æ³•<br>
â‘¡ç”¨onFulfiledï¼ŒonRejectedæ¥æ”¶p.then()ä¼ å…¥çš„valueå’Œreason</p>
<p>ç»¼ä¸Šï¼Œå†™å‡ºçš„ä»£ç å¦‚ä¸‹ï¼š</p>
<pre><code>then(onFulfilled, onRejected) {
                //onFulfilledå¦‚æœæˆåŠŸäº†ï¼Œåº”è¯¥è¢«è°ƒç”¨
                if(this.state==='fulfilled'){
                    onFulfilled(this.value) 
                }
                //onRejectedå¦‚æœæˆåŠŸäº†ï¼Œåº”è¯¥è¢«è°ƒç”¨
                if(this.state==='rejected'){
                    onRejected(this.reason)
                }

            }
</code></pre>
<p>æ¥ä¸‹æ¥æˆ‘ä»¬æ¥è§£å†³å¼‚æ­¥é—®é¢˜</p>
<p>#ä¸‰ã€å¼‚æ­¥é—®é¢˜è§£å†³</p>
<p><strong>é—®é¢˜ï¼š</strong><br>
å½“ä»£ç å¦‚ä¸‹æ—¶ï¼š</p>
<pre><code>const p = new Promise((resolve, reject) =&gt; {
            setTimeout(() =&gt; {
                resolve(200)
            }, 1000)
        })

        p.then(res =&gt; {
            console.log(res);
        })
</code></pre>
<p>ä¼šé‡åˆ°then()åœ¨stateçŠ¶æ€æ”¹å˜ä¹‹å‰å°±æ‰§è¡Œï¼Œå¯¼è‡´æ‰§è¡Œthen()æ—¶çš„stateä»ç„¶æ˜¯pendingçŠ¶æ€</p>
<p><strong>éœ€æ±‚ï¼š</strong><br>
â‘ then()çš„æ‰§è¡Œä¸ç›´æ¥è¾“å‡ºç»“æœï¼Œè€Œæ˜¯å°†å¾—åˆ°çš„æ•°æ®å…ˆå…¨éƒ¨å­˜æ”¾åœ¨ä¸¤ä¸ªæ•°ç»„ä¸­ï¼ˆæˆåŠŸå’Œå¤±è´¥ï¼‰ï¼Œåœ¨resolveæˆ–rejectæ‰§è¡Œåå†å°†æ•°ç»„ä¸­çš„å‡½æ•°è¾“å‡º<br>
â‘¡éœ€è¦å¢åŠ ä¸€ä¸ªifåˆ¤æ–­stateå¦‚æœæ˜¯pendingï¼Œå°†æ•°æ®å­˜å‚¨åœ¨æ•°ç»„ä¸­<br>
â‘¢åœ¨resolveå’Œrejectæ–¹æ³•ä¸­éå†ä¸¤æ•°ç»„å¾—åˆ°æ•°æ®</p>
<p><strong>æ³¨æ„ï¼š</strong><font color="red">(è¿™ä¸ªçœŸçš„å¾ˆé‡è¦ï¼ï¼ï¼ğŸ™‰ğŸ™‰ğŸ™‰)</font><br>
â‘ å‡½æ•°åœ¨æ•°ç»„ä¸­çš„å­˜å‚¨éœ€è¦ç”¨åˆ°å‡½æ•°çš„é—­åŒ…(åœ¨å‡½æ•°çš„å†…éƒ¨åº”ç”¨åˆ°å¤–éƒ¨çš„å‚æ•°)â€”â€”åˆ©ç”¨é—­åŒ…å°†valueæˆ–reasonå‚¨å­˜åœ¨å‡½æ•°ä¸­ï¼Œå¹¶æ•´åˆè‡³æ•°ç»„</p>
<pre><code>//é—­åŒ…
this.onResolvedCallbacks.push(() =&gt; {
                        onFulfilled(this.value)
                    })
//éé—­åŒ…
this.onResolvedCallbacks.push(onFulfilledï¼‰
</code></pre>
<p>ç»¼ä¸Šï¼Œå†™å‡ºçš„ä»£ç å¦‚ä¸‹ï¼š</p>
<pre><code>class Promise {
            constructor(executor) {
                this.state = 'pending'

                this.value = null;
                this.reason = null;

                this.onResolvedCallbacks = [];
                this.onRejectedCallbacks = [];

                const resolve = (value) =&gt; {
                    if (this.state === 'pending') {
                        this.state = 'fulfiled';
                        this.value = value;
                        //éå†æ‰§è¡Œè°ƒç”¨æˆåŠŸçš„æ•°ç»„
                        this.onResolvedCallbacks.forEach(fn =&gt; fn()) //fn()å³ä¸ºå†…éƒ¨å­˜å‚¨çš„å‡½æ•°
                    }
                };

                const reject = (reason) =&gt; {
                    if (this.state === 'pending') {
                        this.state = 'rejected';
                        this.reason = reason;
                        //éå†æ‰§è¡Œè°ƒç”¨å¤±è´¥çš„æ•°ç»„
                        this.onRejectedCallbacks.forEach(fn =&gt; fn())
                    }
                };

                try {
                    executor(resolve, reject);
                } catch (reason) {
                    reject(reason);
                }
            }

            then(onFulfilled, onRejected) {
                //onFulfilledå¦‚æœæˆåŠŸäº†ï¼Œåº”è¯¥è¢«è°ƒç”¨
                if (this.state === 'fulfilled') {
                    onFulfilled(this.value)
                }
                //onRejectedå¦‚æœæˆåŠŸäº†ï¼Œåº”è¯¥è¢«è°ƒç”¨
                if (this.state === 'rejected') {
                    onRejected(this.reason)
                }

                if (this.state === 'pending') {
                    //å°†æˆåŠŸçš„æ—¶å€™è¦å¹²çš„äº‹å‚¨å­˜èµ·æ¥
                    this.onResolvedCallbacks.push(() =&gt; {
                        onFulfilled(this.value)
                    })
                    //å°†å¤±è´¥çš„æ—¶å€™è¦å¹²çš„äº‹å‚¨å­˜èµ·æ¥
                    this.onRejectedCallbacks.push(() =&gt; {
                        onRejected(this.reason)
                    })
                }

            }
        }


        const p = new Promise((resolve, reject) =&gt; {
            //resolveå’Œrejectæ˜¯Promiseå†…éƒ¨å®ç°å¥½çš„å‡½æ•°
            //è¿™é‡Œçš„ä»£ç æ˜¯ç«‹åˆ»å¯æ‰§è¡Œçš„
            setTimeout(() =&gt; {
                resolve(200)
            }, 1000)

        })

        p.then(res =&gt; {
            console.log(res,'1');
        })

        p.then(res =&gt; {
            console.log(res,'2');
        })

        p.then(res =&gt; {
            console.log(res,'3');
        })
</code></pre>
<p>å¾—åˆ°ä»¥ä¸‹ç»“æœ(1så)ï¼š</p>
<blockquote>
<p>200 '1'<br>
200 '2'<br>
200 '3'</p>
</blockquote>
<p>æ¥ä¸‹æ¥æˆ‘ä»¬æ¥å¤„ç†é“¾å¼é—®é¢˜</p>
<p>#å››ã€é“¾å¼é—®é¢˜è§£å†³</p>
<p><strong>éœ€æ±‚ï¼š</strong><br>
â‘ ä¸Šä¸€ä¸ª.thenè¦è¿”å›ä¸€ä¸ªpromiseå¯¹è±¡<br>
â‘¡ä¸‹ä¸€ä¸ª.thençš„å‚æ•°ï¼Œè¦æ‹¿åˆ°ä¸Šä¸€ä¸ª.thençš„å›è°ƒè¿”å›å€¼<br>
â‘¢è®¾ç½®å‚æ•°xä¸ºonFulfilledæˆåŠŸçš„.thenå›è°ƒçš„è¿”å›å€¼ï¼Œå¹¶é€šè¿‡resolve(x)æ¥è¿›è¡Œé“¾å¼æ“ä½œ</p>
<p><strong>æ³¨æ„ï¼š</strong><font color="red">(çœŸçš„å¾ˆç»•ï¼Œå¥½å¥½ç†è§£ä¸€ä¸‹ğŸ¤¡)</font><br>
â‘ ä»£ç è¿ç”¨äº†é€’å½’çš„æ€æƒ³ï¼Œä¸Šä¸€çº§thenè¿”å›Promsieå¯¹è±¡æ¥å»¶ç»­ä¸‹ä¸€çº§çš„thenï¼Œå› æ­¤éœ€è¦åœ¨thenå‡½æ•°ä¸­æ„é€ ä¸€ä¸ªæ–°çš„Promiseå¯¹è±¡å¹¶è¿”å›ï¼Œåœ¨æ–°çš„Promiseå¯¹è±¡ä¸­é€šè¿‡å½“å‰é˜¶æ®µçš„å›è°ƒå‡½æ•°å€¼å†³å®šä¸‹ä¸€æ­¥æ“ä½œ<br>
â‘¡xå¯èƒ½æ˜¯ä¼ å…¥çš„æ™®é€šå€¼ï¼Œä¹Ÿå¯èƒ½æ˜¯Promiseå¯¹è±¡ï¼Œå› æ­¤è¦ç”¨ä¸€ä¸ªå‡½æ•°æ¥åˆ¤æ–­xçš„ç±»å‹å¹¶è¿›è¡Œç›¸åº”çš„å¤„ç†</p>
<p>ç»¼ä¸Šï¼Œå†™å‡ºçš„ä»£ç å¦‚ä¸‹ï¼š</p>
<pre><code>class Promise {
            constructor(executor) {
                this.state = 'pending'

                this.value = null;
                this.reason = null;

                this.onResolvedCallbacks = [];
                this.onRejectedCallbacks = [];

                const resolve = (value) =&gt; {
                    if (this.state === 'pending') {
                        this.state = 'fulfilled';
                        this.value = value;
                        //éå†æ‰§è¡Œè°ƒç”¨æˆåŠŸçš„æ•°ç»„
                        this.onResolvedCallbacks.forEach(fn =&gt; fn()) //fn()å³ä¸ºå†…éƒ¨å­˜å‚¨çš„å‡½æ•°
                    }
                };

                const reject = (reason) =&gt; {
                    if (this.state === 'pending') {
                        this.state = 'rejected';
                        this.reason = reason;
                        //éå†æ‰§è¡Œè°ƒç”¨å¤±è´¥çš„æ•°ç»„
                        this.onRejectedCallbacks.forEach(fn =&gt; fn())
                    }
                };

                try {
                    executor(resolve, reject);
                } catch (reason) {
                    reject(reason);
                }
            }

            then(onFulfilled, onRejected) {
                let promise2 = new Promise((resolve, reject) =&gt; {
                    //onFulfilledå¦‚æœæˆåŠŸäº†ï¼Œåº”è¯¥è¢«è°ƒç”¨
                    if (this.state === 'fulfilled') {
                        //x æ˜¯onFulfilledæˆåŠŸçš„.thenå›è°ƒçš„è¿”å›å€¼
                        let x = onFulfilled(this.value)
                        //å¯¹xè¿›è¡Œåˆ†æ:
                        //1.å¦‚æœæ˜¯æ™®é€šå€¼ï¼Œç›´æ¥è°ƒç”¨resolve
                        //2.å¦‚æœæ˜¯promiseå¯¹è±¡ï¼Œçœ‹promiseæ˜¯å¦æˆåŠŸ

                        //å°†è¿”å›å€¼è¿”å›
                        resolvePromise(x, resolve, reject)
                    }
                    //onRejectedå¦‚æœæˆåŠŸäº†ï¼Œåº”è¯¥è¢«è°ƒç”¨
                    if (this.state === 'rejected') {
                        onRejected(this.reason)
                        let x = onRejected(this.reason)
                        reject(x)
                    }

                    if (this.state === 'pending') {
                        //å°†æˆåŠŸçš„æ—¶å€™è¦å¹²çš„äº‹å‚¨å­˜èµ·æ¥
                        this.onResolvedCallbacks.push(() =&gt; {
                            onFulfilled(this.value)
                        })
                        //å°†å¤±è´¥çš„æ—¶å€™è¦å¹²çš„äº‹å‚¨å­˜èµ·æ¥
                        this.onRejectedCallbacks.push(() =&gt; {
                            onRejected(this.reason)
                        })
                    }
                })
                return promise2
            }
        }

        function resolvePromise(x, resolve, reject) {
            //åˆ¤æ–­ x æ˜¯å¦æ˜¯ä¸€ä¸ªPromiseå¯¹è±¡
            if (x instanceof Promise) {
                // x.then((value) =&gt; {
                //     resolve(value)
                // }, err =&gt; {
                //     reject(err)
                // })

                //ç®€å†™
                x.then(resolve,reject)
            } else {
                resolve(x)
            }
        }

        const p = new Promise((resolve, reject) =&gt; {
            //resolveå’Œrejectæ˜¯Promiseå†…éƒ¨å®ç°å¥½çš„å‡½æ•°
            //è¿™é‡Œçš„ä»£ç æ˜¯ç«‹åˆ»å¯æ‰§è¡Œçš„
            resolve(400)

        })

        p.then(res =&gt; {
            console.log(res);
            return new Promise((resolve, reject) =&gt; {
                resolve(200)
            })
        }).then(data =&gt; {
            console.log(data);
        })
</code></pre>
<p>å¾—åˆ°ä»¥ä¸‹ç»“æœï¼š</p>
<blockquote>
<p>400<br>
200</p>
</blockquote>
<p>æ¥ä¸‹æ¥æˆ‘ä»¬æ¥å®Œå–„Promiseå…¶ä»–å‰©ä½™çš„å†…å®¹ï¼š</p>
<p>#äº”ã€å‰©ä½™å†…å®¹å®Œå–„</p>
<p>1ã€å¾ªç¯è°ƒç”¨&amp;&amp;å¼‚å¸¸æ•è·<br>
<strong>é—®é¢˜ï¼š</strong></p>
<pre><code>const p = new Promise((resolve, reject) =&gt; {
            resolve(400)
        })

const p2 = p.then((data)=&gt;{
            console.log(data);
            return p2
        })
</code></pre>
<p>å…¶ä¸­ï¼Œç¬¬ä¸€ä¸ªp2ç­‰ä»·äºpromise2ï¼Œç¬¬äºŒä¸ªp2ç­‰ä»·äºx(promise2,xçš„å®šä¹‰è¯¦è§å‰æ–‡),æ˜¾ç„¶promise2ä¸å¯èƒ½ç­‰äºx<br>
<strong>éœ€æ±‚ï¼š</strong><br>
â‘ é€šè¿‡åˆ¤æ–­è¯­å¥æ¥è§£å†³ä»¥ä¸ŠçŸ›ç›¾(å†™åœ¨resolvePromsieå’ŒrejectPromsieä¸­)<br>
â‘¡ä½¿ç”¨<em>try catch</em>è¯­æ³•æ¥æ•è·é”™è¯¯</p>
<p><strong>æ³¨æ„ï¼š</strong><br>
â‘ ç”±äºresolvePromsieå’ŒrejectPromsieå†™åœ¨promise2çš„å†…éƒ¨ï¼Œå› æ­¤å¯¼å…¥æ–¹æ³•çš„promise2æ˜¯ä¸å‡†ç¡®çš„ï¼Œ<em>æ­¤å¤„éœ€è¦ä½¿ç”¨å¼‚æ­¥æ“ä½œï¼ˆsetTimeoutï¼ˆï¼ˆï¼‰=&gt;{},0ï¼‰ï¼‰æ¥è§£å†³é—®é¢˜</em></p>
<p>ç»¼ä¸Šï¼Œå†™å‡ºçš„ä»£ç å¦‚ä¸‹ï¼š</p>
<pre><code>class Promise {
            constructor(executor) {
                this.state = 'pending'

                this.value = null;
                this.reason = null;

                this.onResolvedCallbacks = [];
                this.onRejectedCallbacks = [];

                const resolve = (value) =&gt; {
                    if (this.state === 'pending') {
                        this.state = 'fulfilled';
                        this.value = value;
                        //éå†æ‰§è¡Œè°ƒç”¨æˆåŠŸçš„æ•°ç»„
                        this.onResolvedCallbacks.forEach(fn =&gt; fn()) //fn()å³ä¸ºå†…éƒ¨å­˜å‚¨çš„å‡½æ•°
                    }
                };

                const reject = (reason) =&gt; {
                    if (this.state === 'pending') {
                        this.state = 'rejected';
                        this.reason = reason;
                        //éå†æ‰§è¡Œè°ƒç”¨å¤±è´¥çš„æ•°ç»„
                        this.onRejectedCallbacks.forEach(fn =&gt; fn())
                    }
                };

                try {
                    executor(resolve, reject);
                } catch (reason) {
                    reject(reason);
                }
            }

            then(onFulfilled, onRejected) {
                let promise2 = new Promise((resolve, reject) =&gt; {
                    //onFulfilledå¦‚æœæˆåŠŸäº†ï¼Œåº”è¯¥è¢«è°ƒç”¨
                    if (this.state === 'fulfilled') {
                        setTimeout(() =&gt; {
                            try {
                                //x æ˜¯onFulfilledæˆåŠŸçš„.thenå›è°ƒçš„è¿”å›å€¼
                                let x = onFulfilled(this.value)
                                //å¯¹xè¿›è¡Œåˆ†æ:
                                //1.å¦‚æœæ˜¯æ™®é€šå€¼ï¼Œç›´æ¥è°ƒç”¨resolve
                                //2.å¦‚æœæ˜¯promiseå¯¹è±¡ï¼Œçœ‹promiseæ˜¯å¦æˆåŠŸ

                                //å°†è¿”å›å€¼è¿”å›
                                resolvePromise(x, resolve, reject, promise2)
                            } catch (error) {
                                reject(error)
                            }

                        }, 0)

                    }
                    //onRejectedå¤±è´¥æˆåŠŸäº†ï¼Œåº”è¯¥è¢«è°ƒç”¨
                    if (this.state === 'rejected') {
                        setTimeout(() =&gt; {
                            try {
                                let x = onRejected(this.reason)
                                resolvePromise(x, resolve, reject, promise2)
                            } catch (error) {
                                reject(error)
                            }

                        }, 0)
                    }

                    if (this.state === 'pending') {
                        //å°†æˆåŠŸçš„æ—¶å€™è¦å¹²çš„äº‹å‚¨å­˜èµ·æ¥
                        this.onResolvedCallbacks.push(() =&gt; {
                            setTimeout(() =&gt; {
                                try {
                                    let x = onFulfilled(this.value)
                                    resolvePromise(x, resolve, reject, promise2)
                                } catch (error) {
                                    reject(error)
                                }

                            }, 0)
                        })
                        //å°†å¤±è´¥çš„æ—¶å€™è¦å¹²çš„äº‹å‚¨å­˜èµ·æ¥
                        this.onRejectedCallbacks.push(() =&gt; {
                            setTimeout(() =&gt; {
                                try {
                                    let x = onRejected(this.reason)
                                    resolvePromise(x, resolve, reject, promise2)
                                } catch (error) {
                                    reject(error)
                                }

                            }, 0)
                        })
                    }
                })
                return promise2
            }
        }

        function resolvePromise(x, resolve, reject, promise2) {
            //å¤„ç†å¾ªç¯è°ƒç”¨
            if (x === promise2) {
                const err = new TypeError('Uncaught (in promsie) TypeError:detected for promise #&lt;Promsie&gt;')

                console.error(err)

                return reject(err)
            }
            //åˆ¤æ–­ x æ˜¯å¦æ˜¯ä¸€ä¸ªPromiseå¯¹è±¡
            if (x instanceof Promise) {
                // x.then((value) =&gt; {
                //     resolve(value)
                // }, err =&gt; {
                //     reject(err)
                // })

                //ç®€å†™
                x.then(resolve, reject)
            } else {
                resolve(x)
            }
        }
</code></pre>
<p>2ã€å°†thenä¸­çš„å‚æ•°å˜ä¸ºå¯é€‰<br>
<strong>é—®é¢˜ï¼š</strong><br>
ä¸Šé¢æˆ‘ä»¬å¤„ç† then æ–¹æ³•çš„æ—¶å€™éƒ½æ˜¯é»˜è®¤ä¼ å…¥ onFulfilledã€onRejected ä¸¤ä¸ªå›è°ƒå‡½æ•°ï¼Œä½†æ˜¯å®é™…ä¸ŠåŸç”Ÿ Promise æ˜¯å¯ä»¥é€‰æ‹©å‚æ•°çš„å•ä¼ æˆ–è€…ä¸ä¼ ï¼Œéƒ½ä¸ä¼šå½±å“æ‰§è¡Œ</p>
<pre><code>const promise = new Promise((resolve, reject) =&gt; {
  resolve(400)
})

promise.then().then(value =&gt; console.log(value))
</code></pre>
<p><strong>éœ€æ±‚ï¼š</strong><br>
â‘ é€šè¿‡åˆ¤æ–­è¯­å¥,å°†æ²¡æœ‰ä¼ å…¥å‚æ•°å˜ä¸ºé»˜è®¤å‡½æ•°</p>
<p>ç»¼ä¸Šï¼Œå†™å‡ºçš„thenæ–¹æ³•ä»£ç å¦‚ä¸‹ï¼š</p>
<pre><code>then(onFulfilled, onRejected) {
                if (typeof onFulfilled != 'function') {
                    onFulfilled = function (value) {
                        return value;
                    };
                }
                if (typeof onRejected != 'function') {
                    onRejected = function (reason) {
                        throw reason;
                    };
                }


                let promise2 = new Promise((resolve, reject) =&gt; {...
                return promise2
            }
</code></pre>
<p>3ã€å®ç°resolveå’Œrejectçš„é™æ€è°ƒç”¨</p>
<p>æ¯”è¾ƒç®€å•ï¼Œç›´æ¥ä¸Šä»£ç </p>
<pre><code>// resolve é™æ€æ–¹æ³•
        Promise.resolve = function(value) {
            // å¦‚æœä¼ å…¥ Promise å°±ç›´æ¥è¿”å›
            if (value instanceof Promise) {
                return value;
            }

            // è½¬æˆå¸¸è§„æ–¹å¼
            return new Promise(resolve =&gt; {
                resolve(value);
            });
        }

        // reject é™æ€æ–¹æ³•
        Promise.reject = function(reason) {
            return new Promise((resolve, reject) =&gt; {
                reject(reason);
            });
        }
        ```

        4ã€å‰©ä½™æ–¹æ³•

        â‘ finallyï¼š(æ¯”è¾ƒå°‘ç”¨)
        åŠŸèƒ½ï¼šæ— è®ºä¼ å…¥çš„æ˜¯resolveè¿˜æ˜¯rejectéƒ½ä¼šè¾“å‡º
        ```
        finally(fn) {
                return this.then(
                    (value) =&gt; {
                        fn();
                        return value;
                    },
                    (reason) =&gt; {
                        fn();
                        throw reason;
                    }
                );
            };
        ```

        â‘¡catchï¼š
        ```
        catch(onRejected) {
                return this.then(null, onRejected);
            };
        ```

        â‘¢allï¼š
        åŠŸèƒ½ï¼šæ¥å—ä¸€ä¸ªpromiseæ•°ç»„ï¼Œå½“æ‰€æœ‰promiseçŠ¶æ€resolveåï¼Œæ‰§è¡Œresolve
        ```
        Promise.all = function (promises) {
            return new Promise((resolve, reject) =&gt; {
                if (promises.length === 0) {
                    resolve([]);
                } else {
                    let result = [];
                    let index = 0;
                    for (let i = 0; i &lt; promises.length; i++) {
                        promises[i].then(
                            (data) =&gt; {
                                result[i] = data;
                                if (++index === promises.length) {
                                    resolve(result);
                                }
                            },
                            (err) =&gt; {
                                reject(err);
                                return;
                            }
                        );
                    }
                }
            });
        };
        ```

        â‘£raceï¼š
        åŠŸèƒ½ï¼šæ¥å—ä¸€ä¸ªpromiseæ•°ç»„ï¼Œå½“æœ‰ä¸€ä¸ªpromiseçŠ¶æ€resolveåï¼Œæ‰§è¡Œresolve(è°å¿«è°å…ˆæ‰§è¡Œ)
        ```
        Promise.race = function (promises) {
            return new Promise((resolve, reject) =&gt; {
                if (promises.length === 0) {
                    resolve();
                } else {
                    let index = 0;
                    for (let i = 0; i &lt; promises.length; i++) {
                        promises[i].then(
                            (data) =&gt; {
                                resolve(data);
                            },
                            (err) =&gt; {
                                reject(err);
                                return;
                            }
                        );
                    }
                }
            });
        };
        ```

        ä»¥ä¸Šï¼ŒPromiseçš„å¤§è‡´åŠŸèƒ½å°±å†™å®Œäº†ğŸ¤¤ğŸ¤¤ğŸ¤¤

        ä¸‹é¢æ˜¯æœ€åæ•´ç†å¥½çš„ä»£ç ï¼š
        ```
        class Promise {
            constructor(executor) {
                this.state = 'pending'

                this.value = null;
                this.reason = null;

                this.onResolvedCallbacks = [];
                this.onRejectedCallbacks = [];

                const resolve = (value) =&gt; {
                    if (this.state === 'pending') {
                        this.state = 'fulfilled';
                        this.value = value;
                        //éå†æ‰§è¡Œè°ƒç”¨æˆåŠŸçš„æ•°ç»„
                        this.onResolvedCallbacks.forEach(fn =&gt; fn()) //fn()å³ä¸ºå†…éƒ¨å­˜å‚¨çš„å‡½æ•°
                    }
                };

                const reject = (reason) =&gt; {
                    if (this.state === 'pending') {
                        this.state = 'rejected';
                        this.reason = reason;
                        //éå†æ‰§è¡Œè°ƒç”¨å¤±è´¥çš„æ•°ç»„
                        this.onRejectedCallbacks.forEach(fn =&gt; fn())
                    }
                };

                try {
                    executor(resolve, reject);
                } catch (reason) {
                    reject(reason);
                }
            }

            then(onFulfilled, onRejected) {
                if (typeof onFulfilled != 'function') {
                    onFulfilled = function (value) {
                        return value;
                    };
                }
                if (typeof onRejected != 'function') {
                    onRejected = function (reason) {
                        throw reason;
                    };
                }


                let promise2 = new Promise((resolve, reject) =&gt; {
                    //onFulfilledå¦‚æœæˆåŠŸäº†ï¼Œåº”è¯¥è¢«è°ƒç”¨
                    if (this.state === 'fulfilled') {
                        setTimeout(() =&gt; {
                            try {
                                //x æ˜¯onFulfilledæˆåŠŸçš„.thenå›è°ƒçš„è¿”å›å€¼
                                let x = onFulfilled(this.value)
                                //å¯¹xè¿›è¡Œåˆ†æ:
                                //1.å¦‚æœæ˜¯æ™®é€šå€¼ï¼Œç›´æ¥è°ƒç”¨resolve
                                //2.å¦‚æœæ˜¯promiseå¯¹è±¡ï¼Œçœ‹promiseæ˜¯å¦æˆåŠŸ

                                //å°†è¿”å›å€¼è¿”å›
                                resolvePromise(x, resolve, reject, promise2)
                            } catch (error) {
                                reject(error)
                            }

                        }, 0)

                    }
                    //onRejectedå¤±è´¥æˆåŠŸäº†ï¼Œåº”è¯¥è¢«è°ƒç”¨
                    if (this.state === 'rejected') {
                        setTimeout(() =&gt; {
                            try {
                                let x = onRejected(this.reason)
                                resolvePromise(x, resolve, reject, promise2)
                            } catch (error) {
                                reject(error)
                            }

                        }, 0)
                    }

                    if (this.state === 'pending') {
                        //å°†æˆåŠŸçš„æ—¶å€™è¦å¹²çš„äº‹å‚¨å­˜èµ·æ¥
                        this.onResolvedCallbacks.push(() =&gt; {
                            setTimeout(() =&gt; {
                                try {
                                    let x = onFulfilled(this.value)
                                    resolvePromise(x, resolve, reject, promise2)
                                } catch (error) {
                                    reject(error)
                                }

                            }, 0)
                        })
                        //å°†å¤±è´¥çš„æ—¶å€™è¦å¹²çš„äº‹å‚¨å­˜èµ·æ¥
                        this.onRejectedCallbacks.push(() =&gt; {
                            setTimeout(() =&gt; {
                                try {
                                    let x = onRejected(this.reason)
                                    resolvePromise(x, resolve, reject, promise2)
                                } catch (error) {
                                    reject(error)
                                }

                            }, 0)
                        })
                    }
                })
                return promise2
            }

            finally(fn) {
                return this.then(
                    (value) =&gt; {
                        fn();
                        return value;
                    },
                    (reason) =&gt; {
                        fn();
                        throw reason;
                    }
                );
            };

            catch (onRejected) {
                return this.then(null, onRejected);
            };
        }

        // resolve é™æ€æ–¹æ³•
        Promise.resolve = function (value) {
            // å¦‚æœä¼ å…¥ Promise å°±ç›´æ¥è¿”å›
            if (value instanceof Promise) {
                return value;
            }

            // è½¬æˆå¸¸è§„æ–¹å¼
            return new Promise(resolve =&gt; {
                resolve(value);
            });
        }

        // reject é™æ€æ–¹æ³•
        Promise.reject = function (reason) {
            return new Promise((resolve, reject) =&gt; {
                reject(reason);
            });
        }

        //æ¥å—ä¸€ä¸ªpromiseæ•°ç»„ï¼Œå½“æ‰€æœ‰promiseçŠ¶æ€resolveåï¼Œæ‰§è¡Œresolve
        Promise.all = function (promises) {
            return new Promise((resolve, reject) =&gt; {
                if (promises.length === 0) {
                    resolve([]);
                } else {
                    let result = [];
                    let index = 0;
                    for (let i = 0; i &lt; promises.length; i++) {
                        promises[i].then(
                            (data) =&gt; {
                                result[i] = data;
                                if (++index === promises.length) {
                                    resolve(result);
                                }
                            },
                            (err) =&gt; {
                                reject(err);
                                return;
                            }
                        );
                    }
                }
            });
        };

        //æ¥å—ä¸€ä¸ªpromiseæ•°ç»„ï¼Œå½“æœ‰ä¸€ä¸ªpromiseçŠ¶æ€resolveåï¼Œæ‰§è¡Œresolve
        Promise.race = function (promises) {
            return new Promise((resolve, reject) =&gt; {
                if (promises.length === 0) {
                    resolve();
                } else {
                    let index = 0;
                    for (let i = 0; i &lt; promises.length; i++) {
                        promises[i].then(
                            (data) =&gt; {
                                resolve(data);
                            },
                            (err) =&gt; {
                                reject(err);
                                return;
                            }
                        );
                    }
                }
            });
        };



        function resolvePromise(x, resolve, reject, promise2) {
            //å¤„ç†å¾ªç¯è°ƒç”¨
            if (x === promise2) {
                const err = new TypeError('Uncaught (in promsie) TypeError:detected for promise #&lt;Promsie&gt;')

                console.error(err)

                return reject(err)
            }
            //åˆ¤æ–­ x æ˜¯å¦æ˜¯ä¸€ä¸ªPromiseå¯¹è±¡
            if (x instanceof Promise) {
                // x.then((value) =&gt; {
                //     resolve(value)
                // }, err =&gt; {
                //     reject(err)
                // })

                //ç®€å†™
                x.then(resolve, reject)
            } else {
                resolve(x)
            }
        }
        ```
Promiseçš„æ‰‹å†™éƒ¨åˆ†åŸºæœ¬å¤§åŠŸå‘Šæˆ ğŸ‰ğŸ‰ğŸ‰
åœ¨åç»­è¿˜ä¼šé€šè¿‡ Promise A+ è§„èŒƒå¯¹æˆ‘ä»¬çš„ä»£ç è¿›è¡Œæ ¡éªŒï¼Œæ¥æ›´åŠ å®Œå–„æˆ‘ä»¬çš„ä»£ç ğŸ‘ŠğŸ‘ŠğŸ‘Š

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScriptä¸­çš„ç±»æ–¹æ³•ã€å¯¹è±¡æ–¹æ³•ã€åŸå‹æ–¹æ³•]]></title>
        <id>https://uaenaTzx.github.io/post/javascript-zhong-de-lei-fang-fa-dui-xiang-fang-fa-yuan-xing-fang-fa/</id>
        <link href="https://uaenaTzx.github.io/post/javascript-zhong-de-lei-fang-fa-dui-xiang-fang-fa-yuan-xing-fang-fa/">
        </link>
        <updated>2022-05-10T02:19:41.000Z</updated>
        <content type="html"><![CDATA[<p>å®šä¹‰ï¼š<br>
â‘ ç±»æ–¹æ³•ï¼šä¹Ÿå«å‡½æ•°æ–¹æ³•(åœ¨jsä¸­å¯ä»¥ä¸ºå‡½æ•°æ·»åŠ å±æ€§ä»¥åŠæ–¹æ³•)ï¼›<br>
â‘¡å¯¹è±¡æ–¹æ³•ï¼šåŒ…æ‹¬æ„é€ å‡½æ•°ä¸­çš„æ–¹æ³•ä»¥åŠå…¶åŸå‹ä¸Šé¢çš„æ–¹æ³•<font color="red">(å¯¹è±¡æ–¹æ³•åŒ…å«äº†åŸå‹æ–¹æ³•)ï¼›</font><br>
â‘¢åŸå‹æ–¹æ³•ï¼šä¸€èˆ¬ç”¨äºå¯¹è±¡å®ä¾‹å…±äº«ï¼Œä¸ºé¿å…å†…å­˜å¤ç”¨è€Œåœ¨åŸå‹ä¸Šæ·»åŠ æ–¹æ³•ï¼›</p>
<p><strong>jsä¸­çš„functionä½œä¸ºæ„é€ å‡½æ•°æ—¶ï¼Œè¢«è§†ä¸ºä¸€ä¸ªç±»ã€‚å¯ä»¥é€šè¿‡new xxxæ¥å¾—åˆ°ä¸€ä¸ªå®ä¾‹å¯¹è±¡</strong><br>
ä»¥ä¸‹æ˜¯ä¸€ä¸ªç¤ºä¾‹ä»£ç ï¼Œæ¥å˜æ¸…ä»¥ä¸Šä¸‰è€…çš„åŒºåˆ«ï¼š</p>
<pre><code>function People(name){ 
  this.name=name; 
  //å¯¹è±¡æ–¹æ³• (å®ä¾‹æ–¹æ³•)
  //æ¯ä¸ªå¯¹è±¡å®ä¾‹éƒ½æœ‰çš„æ–¹æ³•
  //åªæœ‰å¯¹è±¡å®ä¾‹æ‰èƒ½è°ƒç”¨çš„æ–¹æ³•
  this.Name=function(){
    console.log(&quot;My name is &quot;+this.name); 
  } 
} 
//ç±»æ–¹æ³• 
//åªæœ‰åŸå‹æ‰èƒ½è°ƒç”¨çš„æ–¹æ³•
People.Sleep=function(){ 
  console.log(&quot;People need sleep&quot;); 
} 
//åŸå‹æ–¹æ³• 
//æ‰€æœ‰å¯¹è±¡å®ä¾‹å…±äº«çš„æ–¹æ³•
//åŸå‹å¯é€šè¿‡People.prototype.learn()è°ƒç”¨
People.prototype.learn=function(){ 
  console.log('learning'); 
}
var Uaena =new People(&quot;Uaena&quot;); 
Uaena.Name();         //å¯¹è±¡æ–¹æ³•éœ€è¦é€šè¿‡å®ä¾‹åŒ–å¯¹è±¡å»è°ƒç”¨ 
People.Sleep();        //ç±»æ–¹æ³•ä¸éœ€è¦é€šè¿‡å®ä¾‹åŒ–å¯¹è±¡å»è°ƒç”¨ 
Uaena.learn();         //åŸå‹æ–¹æ³•éœ€è¦é€šè¿‡å®ä¾‹åŒ–å¯¹è±¡å»è°ƒç”¨
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[axiosçš„äºŒæ¬¡å°è£…]]></title>
        <id>https://uaenaTzx.github.io/post/axios-de-er-ci-feng-zhuang/</id>
        <link href="https://uaenaTzx.github.io/post/axios-de-er-ci-feng-zhuang/">
        </link>
        <updated>2022-05-08T09:29:03.000Z</updated>
        <content type="html"><![CDATA[<p>æ„ä¹‰ï¼š apiç»Ÿä¸€ç®¡ç†,ä¸ç®¡æ¥å£æœ‰å¤šå°‘,æ‰€æœ‰çš„æ¥å£éƒ½å¯ä»¥éå¸¸æ¸…æ™°,å®¹æ˜“ç»´æŠ¤</p>
<p><strong>ä¸ºäº†ç†è§£axiosçš„äºŒæ¬¡å°è£…è¿‡ç¨‹æ€è·¯ï¼Œåšä¸»é€šè¿‡ç®€è¿°çš„æ–¹å¼æ¥èµ°ä¸€éäºŒæ¬¡å°è£…çš„å…¨è¿‡ç¨‹</strong></p>
<p>â‘ æ–‡ä»¶åˆ›å»ºï¼š<br>
åœ¨srcç›®å½•ä¸‹åˆ›å»ºâ€œapiâ€æ–‡ä»¶å¤¹ï¼Œåœ¨æ–‡ä»¶å¤¹é‡Œåˆ›å»ºhttp.jsï¼Œapi.jsï¼Œvote.jsç­‰æ–‡ä»¶</p>
<p>â‘¡ç¬¬ä¸€æ¬¡å°è£…ï¼š<br>
åœ¨http.jsæ–‡ä»¶ä¸­æ·»åŠ axiosçš„é»˜è®¤é…ç½®,å¯¹Getã€Postç­‰æ–¹æ³•ä»¥åŠå„ç±»æ‹¦æˆªå™¨è¿›è¡Œå°è£…</p>
<p>â‘¢ç¬¬äºŒæ¬¡å°è£…â€”â€”å¼•ç”¨http.jsè¿›è¡Œç›¸å…³æ¥å£æ–¹æ³•çš„ç¼–å†™ï¼š</p>
<pre><code>import axios from './http';

function voteAdd(){
    return axios.post('/insertVote');
}
//ä»¥ä¸‹çœç•¥å…¶ä»–æ–¹æ³•

//ç»Ÿä¸€æš´éœ²
export default{
    voteAdd,
}
</code></pre>
<p>â‘£åœ¨api.jsä¸­å¯¼å…¥å­˜æ”¾ç›¸å…³æ¥å£çš„æ–‡ä»¶ï¼š</p>
<pre><code>import vote from './vote'
//ä»¥ä¸‹çœç•¥å…¶ä»–æ¥å£æ–‡ä»¶

export default{
    vote,
}
</code></pre>
<p>æ³¨ï¼šapi.jsçš„ä½œç”¨æ˜¯ç»Ÿä¸€å­˜æ”¾æ‰€æœ‰çš„æ¥å£ï¼Œä¾¿äºåç»­çš„ç®¡ç†å’Œè°ƒè¯•</p>
<p>â‘¤æ¥å£çš„è°ƒç”¨â€”â€”main.js:<br>
<strong>å°†å°è£…å¥½çš„axiosæ”¾å…¥VueåŸå‹å¯¹è±¡çš„$apiä¸Šï¼ˆè¿™ä¸ªæ“ä½œå¯ä»¥å‡å°‘å¾ˆå¤šçš„ç é‡ï¼‰</strong></p>
<pre><code>import api from './api/api'
Vue.prototype.$api = api
</code></pre>
<p>â‘¥æ¥å£çš„è°ƒç”¨â€”â€”app.vueï¼š<br>
åœ¨app.vueä¸­è°ƒç”¨æ¥å£</p>
<pre><code>methods:{
    add(){
        this.$api.vote.voteAdd();
    }
}
</code></pre>
<p>è‡³æ­¤ï¼Œaxiosçš„äºŒæ¬¡å°è£…ç›´è‡³è¿ç”¨å°±ç»“æŸäº†</p>
]]></content>
    </entry>
</feed>