<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://uaenaTzx.github.io</id>
    <title>Uaena_blog</title>
    <updated>2022-06-17T09:37:50.918Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://uaenaTzx.github.io"/>
    <link rel="self" href="https://uaenaTzx.github.io/atom.xml"/>
    <subtitle>菜狗tzx的笔记博客🐕</subtitle>
    <logo>https://uaenaTzx.github.io/images/avatar.png</logo>
    <icon>https://uaenaTzx.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Uaena_blog</rights>
    <entry>
        <title type="html"><![CDATA[css中display:none与visibility:hidden的区别和共性分析]]></title>
        <id>https://uaenaTzx.github.io/post/css_display_visibility/</id>
        <link href="https://uaenaTzx.github.io/post/css_display_visibility/">
        </link>
        <updated>2022-06-16T15:19:15.000Z</updated>
        <content type="html"><![CDATA[<p>从最基础的开始说，它们的区别在于<code>display:none</code><font color="red">不占用原来的位置</font>，而<code>visibility:hidden</code><font color="red">保留原来的位置。</font><br>
接下来要补充的，是更多在细节上的区别（只讲述一些稍微常用的知识点）：</p>
<h1 id="一-displaynone的性质">一、display:none的性质</h1>
<p>1.父元素为<code>display:none</code>，子孙元素也会被设置为<code>display:none</code></p>
<pre><code>.hidden{
  display: none;
}
.visible{
  display: block;//元素显示在页面上，它是块模式显示，和周围的元素不在一行,自己单独一行
}
&lt;div class=&quot;hidden&quot;&gt;
  father
  &lt;div class=&quot;visible&quot;&gt; son&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>结果显示son没有被渲染到页面上</p>
<p>2.无法获取焦点<br>
由于在盒子模型中就没有出现目标元素，何谈获取焦点呢🤡</p>
<p>3.<code>display:none</code>的元素也无法响应事件，诸如捕获、命中目标和冒泡阶段(因为父元素没了，子元素也凉凉)</p>
<p>4.不妨碍<code>form</code>表单的提交</p>
<h1 id="二-visibilityhidden的性质">二、visibility:hidden的性质</h1>
<p>在此之前，先补充一下<code>visibility</code>的四个有效值：<br>
①<code>.visible</code>：在界面上显示<br>
②<code>.hidden</code>：在界面上不可视，但保留元素原来占有的位置<br>
③<code>.collapse</code>：用于表格子元素(如tr,tbody,col,colgroup)时，效果和<code>display:none</code>一样，用于其他元素上时则效果与<code>visibility:hidden</code>一样(几乎不使用)<br>
④<code>.inherit</code>：使元素继承父元素的<code>visibility</code>值</p>
<p>接下来开始讲讲<code>visibility:hidden</code>的性质：<br>
1.父元素为<code>visibility:hidden</code>时，子孙元素可以设置为<code>visibility:visible</code>并且生效</p>
<p>2.同样的，<code>visibility:hidden</code>也不能获取焦点</p>
<p>3.可以响应冒泡~</p>
<p>4.不妨碍<code>form</code>表单的提交</p>
<p>合理的理解两者的区别可以更好地帮助我们设计布局，避免出现重构等问题，还有更多的细节会在之后陆续补充。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[通过js实现简单的组件拖拽效果]]></title>
        <id>https://uaenaTzx.github.io/post/js_tuozhuai/</id>
        <link href="https://uaenaTzx.github.io/post/js_tuozhuai/">
        </link>
        <updated>2022-06-16T15:18:45.000Z</updated>
        <content type="html"><![CDATA[<p><img src="C:/Users/86183/Desktop/Photos/markdown.jpg" alt="盒子模型" loading="lazy"><br>
本文通过js来实现简单的拖拽效果<br>
首先是整体的设计思路：<br>
①鼠标点击：获取拖拽对象，准备拖动<br>
②鼠标拖动：改变页面布局<br>
③鼠标抬起：停止拖动，改变布局结束</p>
<p>实现代码如下：</p>
<pre><code>var o = document.querySelector('div');
  
        //鼠标按下
        o.onmousedown = function (e) {
            //鼠标相对于盒子的位置
            var offsetX = e.clientX - o.offsetLeft;
            var offsetY = e.clientY - o.offsetTop;
            //鼠标移动
            document.onmousemove = function (e) {
                o.style.left = e.clientX - offsetX + &quot;px&quot;;
                o.style.top = e.clientY - offsetY + &quot;px&quot;;
            }
            //鼠标松开
            document.onmouseup = function () {
                //当鼠标松开时，将元素固定在当前位置，取消document的onmousemove事件
                document.onmousemove = null;
                //onmouseup事件只需要执行一次
                document.onmouseup = null;
            }
        }
</code></pre>
<p>对以上代码，需对部分参数做解释：<br>
①offsetLeft：是一个只读属性，返回当前元素相对于 offsetParent （被定位的最近祖先元素）节点左边界的偏移像素值(offsetTop同理)<br>
②e.clientX：返回当事件被触发时鼠标指针相对于浏览器页面的水平坐标（clientY同理）<br>
相似的还有clientLeft、clientTop<br>
③o.style.left：事件对象的left样式属性，它的值代表目标元素距离浏览器页面左侧的值（o.style.top）同理</p>
<p>这样的设计会出现一些问题，比如盒子中存在文字，或盒子自身为图片，由于浏览器的默认行为（文字和图片本身就可以拖拽），我们可以设置return false来阻止它的默认行为，但这种拦截默认行为在IE低版本中并不适用，因此我们可以使用全局捕获来解决这类问题。（注：全局捕获仅适用于IE低版本浏览器）</p>
<pre><code>&lt;button&gt;btn1&lt;/button&gt;
    &lt;button&gt;btn2&lt;/button&gt;
    &lt;script&gt;
        var bts = document.querySelectorAll('button')
 
        bts[0].onclick = function () {
            console.log(1);
        }
        bts[1].onclick = function () {
            console.log(2);
        }
 
         bts[0].setCapture()  //添加全局捕获
         bts[0].releaseCapture() ;//释放全局捕获
&lt;/script&gt;
</code></pre>
<p>一旦为指定节点添加全局捕获，则页面中其它元素就不会触发同类型事件,在这个代码案例中，只会触发btn1的点击事件。<br>
setCapture作用是将所有的鼠标事件捕获到当前文档的指定的对象，可以通过alert 或者 窗口失去焦点 或者 releaseCapture 来结束捕获，否则将会一直捕获。</p>
<p>将全局捕获的思想加入到之前的代码，得到如下完整代码：</p>
<pre><code>var o = document.querySelector('div');
  
        //鼠标按下
        o.onmousedown = function (e) {
			//在高级浏览器中没有setCapture()和releaseCapture()方法
			//所以调用会导致浏览器报错
            if (o.setCapture) {   //IE低版本
                o.setCapture()
            }
			//obj.setCapture &amp;&amp; obj.setCapture(); 简写方式

            e = e || window.event
            //鼠标相对于盒子的位置
            var offsetX = e.clientX - o.offsetLeft;
            var offsetY = e.clientY - o.offsetTop;
            //鼠标移动
            document.onmousemove = function (e) {
                e = e || window.event
                o.style.left = e.clientX - offsetX + &quot;px&quot;;
                o.style.top = e.clientY - offsetY + &quot;px&quot;;
            }
            //鼠标抬起
            document.onmouseup = function () {
                document.onmousemove = null;
                document.onmouseup = null;
                if (o.releaseCapture) {
                    o.releaseCapture();//释放全局捕获   
                }
            }
            return false;//标准浏览器的默认行为
        }
</code></pre>
<p>至此，一个完整拖拽功能的代码就实现了🌝</p>
]]></content>
    </entry>
</feed>