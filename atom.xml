<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://uaenaTzx.github.io</id>
    <title>Uaena_blog</title>
    <updated>2022-06-30T09:09:41.569Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://uaenaTzx.github.io"/>
    <link rel="self" href="https://uaenaTzx.github.io/atom.xml"/>
    <subtitle>菜狗tzx的笔记博客🐕</subtitle>
    <logo>https://uaenaTzx.github.io/images/avatar.png</logo>
    <icon>https://uaenaTzx.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Uaena_blog</rights>
    <entry>
        <title type="html"><![CDATA[阻止事件默认行为]]></title>
        <id>https://uaenaTzx.github.io/post/zu-zhi-shi-jian-mo-ren-xing-wei/</id>
        <link href="https://uaenaTzx.github.io/post/zu-zhi-shi-jian-mo-ren-xing-wei/">
        </link>
        <updated>2022-06-17T09:37:09.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-什么是事件默认行为">一、什么是事件默认行为</h1>
<p>默认行为，一般是指 <code>HTML</code>元素所自带的行为<br>
例如：<br>
①标签<code>a</code>表示跳转链接<br>
②标签<code>input</code>表示提交表单<br>
③<code>mousedown</code>事件，鼠标在文本上进行移动，此时默认行为是选择文本；如果是在图片上，则是退拽图片<br>
……</p>
<p>但是有的场合不需要我们触发事件默认行为。比如表单数据需要通过<code>ajax</code>来异步发送到服务器时，并不需要提交表单，再比如我们不想拖拽图片后，重新再另外一个窗口中展示该图片。此时，需要通过一些操作来取消事件的默认行为</p>
<h1 id="二-阻止事件默认行为">二、阻止事件默认行为</h1>
<p>在此之前，先介绍一个属性<code>cancelable</code>（只读属性），该属性返回一个布尔值，表示事件是否可以取消。返回<code>true</code>时，表示可以取消。否则，表示不可取消</p>
<pre><code>&lt;a id=&quot;test&quot; href=&quot;https://www.123.com&quot;&gt;123&lt;/a&gt;

var test = document.getElementById(&quot;test&quot;);
test.onclick = function (event) {
  console.log(event.cancelable)// true
}
</code></pre>
<p>下面我们来对阻止事件默认行为的方法进行总结：<br>
①preventDefault 方法<br>
preventDefault 方法是 DOM 中最常见，也是最标准的取消浏览器默认行为的方式，无返回值</p>
<pre><code>var test = document.getElementById(&quot;test&quot;);
test.onclick = function(event){
  event.preventDefault();
}
</code></pre>
<p>②returnValue 属性<br>
returnValue 是一个 event 对象上面的属性（可读可写）。默认值是为true，将其设置为 false 就可以取消事件的默认行为（适用于低版本浏览器）</p>
<pre><code>var test = document.getElementById(&quot;test&quot;);
test.onclick = function(event){
  event.returnValue = false;
}
</code></pre>
<p>③return false语句<br>
该语句写在事件处理函数中也可以阻止默认行为。但是该语句后面的代码将不被运行（return false的管辖范围只在所处的函数中，对外无影响）<br>
注：并不只是return false 是会取消默认行为，有时候return true也会有同样的效果，只是习惯问题</p>
<pre><code>var test = document.getElementById(&quot;test&quot;);
test.onclick = function(){
  return false;
}
</code></pre>
<p>以上几种方法选一种习惯的即可，其中第二种不是很常用。🙃</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[css中display:none与visibility:hidden的区别和共性分析]]></title>
        <id>https://uaenaTzx.github.io/post/css_display_visibility/</id>
        <link href="https://uaenaTzx.github.io/post/css_display_visibility/">
        </link>
        <updated>2022-06-16T15:19:15.000Z</updated>
        <content type="html"><![CDATA[<p>从最基础的开始说，它们的区别在于<code>display:none</code><font color="red">不占用原来的位置</font>，而<code>visibility:hidden</code><font color="red">保留原来的位置。</font><br>
接下来要补充的，是更多在细节上的区别（只讲述一些稍微常用的知识点）：</p>
<h1 id="一-displaynone的性质">一、display:none的性质</h1>
<p>1.父元素为<code>display:none</code>，子孙元素也会被设置为<code>display:none</code></p>
<pre><code>.hidden{
  display: none;
}
.visible{
  display: block;//元素显示在页面上，它是块模式显示，和周围的元素不在一行,自己单独一行
}
&lt;div class=&quot;hidden&quot;&gt;
  father
  &lt;div class=&quot;visible&quot;&gt; son&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>结果显示son没有被渲染到页面上</p>
<p>2.无法获取焦点<br>
由于在盒子模型中就没有出现目标元素，何谈获取焦点呢🤡</p>
<p>3.<code>display:none</code>的元素也无法响应事件，诸如捕获、命中目标和冒泡阶段(因为父元素没了，子元素也凉凉)</p>
<p>4.不妨碍<code>form</code>表单的提交</p>
<h1 id="二-visibilityhidden的性质">二、visibility:hidden的性质</h1>
<p>在此之前，先补充一下<code>visibility</code>的四个有效值：<br>
①<code>.visible</code>：在界面上显示<br>
②<code>.hidden</code>：在界面上不可视，但保留元素原来占有的位置<br>
③<code>.collapse</code>：用于表格子元素(如tr,tbody,col,colgroup)时，效果和<code>display:none</code>一样，用于其他元素上时则效果与<code>visibility:hidden</code>一样(几乎不使用)<br>
④<code>.inherit</code>：使元素继承父元素的<code>visibility</code>值</p>
<p>接下来开始讲讲<code>visibility:hidden</code>的性质：<br>
1.父元素为<code>visibility:hidden</code>时，子孙元素可以设置为<code>visibility:visible</code>并且生效</p>
<p>2.同样的，<code>visibility:hidden</code>也不能获取焦点</p>
<p>3.可以响应冒泡~</p>
<p>4.不妨碍<code>form</code>表单的提交</p>
<p>合理的理解两者的区别可以更好地帮助我们设计布局，避免出现重构等问题，还有更多的细节会在之后陆续补充。</p>
]]></content>
    </entry>
</feed>